<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ2 level randomizer</title>
    <link rel="stylesheet" href="style.css">
    <script src="randombg.js"></script>
</head>

<body>
    <div id="snackbar">Some text some message..</div>
    <div id="div1" class="filename-container">
        <label> Options :</label>
        <select onchange="setMod(modOption.value)" name="mod" id="modOption">
            <option value="vnl">VNL</option>
            <option value="rfl">RFL</option>
        </select>

        <label>Filename: </label><select id="filename"></select>
        <input style="width: 40px;" value="1" type="number" min="1" max="40" id="levelnum">
        .json<br>
        <label>Stage: </label>
        <select id="stage"></select>
        <label>Custom list: </label>
        <input type="checkbox" onclick="customList()" id="customList">
        <br>
        <h2>Select Difficulty</h2>
        <div class="select-container">
            <label for="difficulty">Difficulty Level:</label>
            <select id="difficulty" name="difficulty" onchange="updateDifficultyText(this.value)">
                <option hidden defaultSelected>-</option>
                <option value="1">Easy</option>
                <option value="2">Normal</option>
                <option value="3">Inzane</option>
                <option value="4">CRAAAZY!</option>
                <option value="50">Johan</option>
            </select>
        </div><br>
    </div>
    <div class="filename-container">
        <button id="Copy" onclick="copyCode()">Copy</button>
        <p> or </p>
        <button id="buttonA" onclick="startDownload()">Download</button>
    </div>

    <h4><a id="home" href="index.html">Home page</a></h4>
    <script>
        let difficulty = localStorage.getItem('difficulty');
        let difficultyText = document.getElementById("difficulty").options[document.getElementById("difficulty").selectedIndex].text;
        if (localStorage.getItem('difficulty') != null){
            document.getElementById('difficulty').selectedIndex = localStorage.getItem('difficulty')
        }
        function updateDifficultyText(value){
            localStorage.setItem('difficulty',value);
            reload();
        }
        console.log(difficulty)

        function copyCode() {
            const text = JSON.stringify(level, null, 2); // Converts the object to a formatted JSON string
            navigator.clipboard.writeText(text);
            snackbar("Level code copied.");
        }
        function snackbar(text){
            var x = document.getElementById("snackbar")
            x.textContent = text;
            // Add the "show" class to DIV
            x.className = "show";

            // After 3 seconds, remove the show class from DIV
            setTimeout(function () { x.className = x.className.replace("show", ""); reload();}, 3000);
        }

        function startDownload() {
            // Get the filename from the input fields
            let filename = document.getElementById('filename').value;
            filename += document.getElementById('levelnum').value + '.json';
            text = JSON.stringify(level, null, 2);
            filename = filename.toLowerCase();

            // Convert the level object to a JSON string
            let dataStr = text;

            // Create a Blob object from the data string
            let dataBlob = new Blob([dataStr], { type: 'application/json' });

            // Create a URL for the Blob object
            let url = URL.createObjectURL(dataBlob);

            // Create a link element
            let link = document.createElement('a');
            link.download = filename;
            link.href = url;

            // Append the link to the body
            document.body.appendChild(link);

            // Simulate a click on the link
            link.click();

            // Remove the link from the body
            document.body.removeChild(link);

            snackbar('Level downloaded.')


        }


        let mod = localStorage.getItem('mod');
        if (mod == null) { mod = 'vnl' }
        document.getElementById('modOption').value = mod;

        function setMod(mod) {
            localStorage.setItem('mod', mod);
            reload();
        }

        function rtid(str, module) {
            return `RTID(${str}@${module})`;
        }


        let interval = Math.min(10, randint(8, 2 * difficulty));
        let minWaves = 3;
        let maxWaves = 6;

        // Formula to calculate flags based on difficulty
        let flags = Math.min(maxWaves, minWaves + Math.floor(difficulty * Math.random()));

        // Calculate the total based on interval and flags
        let total = interval * flags;

        function extraSpecials() {
            switch (mod) {
                case 'rfl':
                    return [
                        "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus", "beach_snorkel",
                        "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite", "beach_surfer",
                        "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser",
                        "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler", "zcorp_racer_chair", "zcorp_consultant",
                        "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                        "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "iceage_dodo_veteran", "iceage_hunter_veteran",
                        "eighties_arcade", "eighties_arcade_basic", "iceage_weaselhoarder_veteran", "iceage_chief", "iceage_chief_veteran",
                        "eighties_boombox", "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry", "iceage_troglobite_basic", "modern_newspaper", "modern_balloon", "modern_allstar",
                        "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco", "dark_explorer", "explorer_veteran",
                        "lostcity_explorer", "barrelroller_explosive", "ghost_scare", "halloween_ghost", "halloween_crow", "future_protector_generator", "general_treadmill_phase2", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic",
                        "egypt_gargantuar", "cowboy_gargantuar", "future_gargantuar", "dark_gargantuar", "beach_gargantuar", "iceage_gargantuar", "lostcity_gargantuar", "dino_gargantuar", "tutorial_gargantuar", "summer_gargantuar", "steam_gargantuar"
                    ];
                    break;
                default:
                    return [];
                    break;
            }
        }

        function extraStages() {
            switch (mod) {
                case 'rfl':
                    return ['Summer'];
                    break;

                default:
                    return [];
                    break;
            }
        }
        let specials = []
        switch (mod) {
            case 'rfl':
                specials = [
                    "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus", "beach_snorkel","roman_medusa","steam_furnace",
                    "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite", "beach_surfer","roman_healer","roman_shield_pair",
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser", "pumpkin_scarecrow","roman_shield_pair",
                    "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler", "zcorp_racer_chair", "zcorp_consultant",
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1","roman_ballista",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "iceage_dodo_veteran", "iceage_hunter_veteran",
                    "eighties_arcade", "eighties_arcade_basic", "iceage_weaselhoarder_veteran", "iceage_chief", "iceage_chief_veteran",
                    "eighties_boombox", "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry", "iceage_troglobite_basic", "modern_newspaper", "modern_balloon", "modern_allstar",
                    "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco", "dark_explorer", "explorer_veteran",
                    "lostcity_explorer", "barrelroller_explosive", "ghost_scare", "halloween_ghost", "halloween_crow", "future_protector_generator", "general_treadmill_phase2", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic"
                ];
            default:
                specials = [
                    "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus",
                    "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser",
                    "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler",
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter",
                    "eighties_boombox", "dino_bully", "modern_newspaper", "modern_balloon", "modern_allstar",
                    "prospector", "west_bull", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco"
                ];
        }
        function createOptions(arr) {
            const selectElement = document.createElement('select');

            arr.forEach((value) => {
                const optionElement = document.createElement('option');
                optionElement.value = value;
                optionElement.textContent = value;
                selectElement.appendChild(optionElement);
            });

            return selectElement;
        }

        specials.push(...extraSpecials());
        let basics = ["tutorial","carnie","roman", "mummy", "pirate", "cowboy", "future", "dark", "beach", "beach_fem", "iceage", "lostcity", "eighties", "dino", "summer", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem", "steam_miner", "steam","hero"];
        let imps = ["tutorial_imp", "egypt_imp", "pirate_imp", "future_imp", "dark_imp", "beach_imp", "iceage_imp", "lostcity_imp", "eighties_imp", "dino_imp", "steam_imp","zcorp_imp","zcorp_imp"];
        let gargs = ["egypt_gargantuar", "cowboy_gargantuar", "future_gargantuar", "dark_gargantuar", "beach_gargantuar", "iceage_gargantuar", "lostcity_gargantuar", "dino_gargantuar", "tutorial_gargantuar", "summer_gargantuar", "steam_gargantuar","zcorp_gargantuar","zcorp_gargantuar",,"zcorp_gargantuar",,"zcorp_gargantuar","zcorp_gargantuar"]
        let validArmor4 = ["tutorial", "mummy", "pirate", "cowboy", "future", "dino", "dark"]
        let flyingUnits = ["lostcity_bug_armor2", "lostcity_bug_armor1", "modern_balloon", "tutorial_balloon", "future_jetpack_veteran", "future_jetpack", "pelican", "cannon", "lostcity_bug", "summer_bug", "summer_bug_armor1", "summer_bug_armor2", "future_jetpack_veteran", "spongebob_vi", "spongebob_vi_armor1", "spongebob_vi_armor2", "seagull", "steam_inventor"];
        let stage = ["Modern", "Egypt", "Pirate", "West", "Future", "Dark", "Beach", "Iceage", "LostCity", "Eighties", "Dino"];
        stage.push(...extraStages());
        let stageBtn = localStorage.getItem('selectedStage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let select = document.getElementById('filename');
            let txt = stage[i];
            if (i == 2) { txt = 'Cowboy' }
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        function linearSearchAndRemove(array, element) {
            let index = array.indexOf(element);
            if (index !== -1) {
                array.splice(index, 1);
            }
            return array;
        }



        stage.unshift('random');
        let select = document.getElementById('stage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let txt = stage[i];
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        select.addEventListener('change', function () {
            localStorage.setItem('selectedStage', this.value);
            reload();
        });
        stage.shift();

        if (stageBtn === 'random') {
            stage = choice(stage);
        }
        else stage = stageBtn;
        // Determine the max number of specials based on difficulty scaling
        let maxSpecials;
        if (difficulty === 1) { // Easy difficulty
            maxSpecials = randint(2, 4);  // 2-4 specials
        } else if (difficulty <= 3) { // Normal difficulty (2-3)
            maxSpecials = randint(10, 20);  // 10-20 specials
        } else if (difficulty <= 6) { // Insane difficulty (4-6)
            maxSpecials = randint(25, 35);  // 25-35 specials
        } else if (difficulty <= 9) { // Crazy difficulty (7-9)
            maxSpecials = randint(45, 60);  
        } else { // Johan difficulty (10+)
            maxSpecials = randint(80, specials.length);  // No limit (all specials)
        }

        console.log("Max Specials:", maxSpecials);  // Debugging output

        // Scale the number of specials to pick based on difficulty, capped by maxSpecials
        let numSpecials = Math.min(randint(1, difficulty * 5), maxSpecials);
        console.log("Number of Specials to Pick:", numSpecials);
        // Debugging output

        // Select the actual specials based on the final number
        let pool = sample(specials, numSpecials);
        console.log("Picked Specials Pool:", pool);  // Debugging output





        let minibossPool = [
            "miniboss_impfinity",
            "birthday_caketank",
            "hero_zmech",
            "hero_crystalskull",
            "feastivus_multplicity",
            "mashup_arcade",
            "mashup_arcade_cabinet_miniboss",
            "hero_electricboogaloo",
            "hero_armor1",
            "hero_armor2",
            "hero_flag",
            "hero_disco_mech",
            "hero_jetpack_disco",
            "hero_impfinity",
            "hero_neptuna",
            "hero_rustbolt",
            "hero_superbrainz",
            "hero_weaselhoarder",
            "galaxy_dodo",
            "hero_barrelroller",
            "hero_barrel",
            "hero_smash"
        ];

        // Special logic for difficulty higher than 40
        
        if (difficulty > 40) {
            pool.push("hero_zmech");
            if (Math.random()*10 <= 50) {  // 50% chance to use the miniboss pool
                pool = minibossPool;
            }
        }
        if (pool.includes("dark_king")) {
            basics = ['dark'];
        }

        if (pool.includes("ra")) {
            basics = ['mummy'];
        }

        // Check if the stage is 'Beach'
        if (stage == 'Beach') {
            basics = ['beach', 'beach_fem'];
            pool.push("beach_snorkel");

            // 50% chance to add "beach_fisherman"
            if (Math.random() < 0.5) {
                pool.push("beach_fisherman");
            }

            // Replace "dark_king" or "piano" with beach-themed characters
            pool = pool.map(item => {
                if (item === "dark_king") {
                    return "beach_octopus";
                } else if (item === "piano") {
                    return "beach_surfer";
                }
                return item;
            });
            if (stage == 'Dino') {
                basics = ['dino'];
                if (Math.random() < 0.5) {
                    pool.push("dino_imp");
                }
            }
        } else if (pool.includes("piano")) {
            basics = ['cowboy'];
        }
        if (Math.random() < (0.01 * difficulty)) {
            pool.push(...sample(gargs, randint(0, 2)));  // Higher chance of adding Gargantuars
        }

        if (Math.random() < (0.01 * difficulty)) {
            pool.push(...sample(imps, randint(0, 3)));   // Higher chance of adding Imps
        }
        console.log(pool)

        if (mod == 'vnl') {
            pool.unshift(choice(validArmor4) + '_armor4')
        }
        else pool.unshift(choice(basics) + '_armor4');
        pool.unshift(choice(basics) + '_armor2');
        pool.unshift(choice(basics) + '_armor1');
        pool.unshift(choice(basics));
        if (pool[0] == 'summer') {
            pool[0] = 'summer_basic';
        }
        if (pool[0] == 'hero') {
            pool[0] = 'hero_electricboogaloo';
        }
        let basicPool = pool.toSpliced(4, pool.length);
        basicPool[0] = rtid(basicPool[0], 'ZombieTypes')
        basicPool[1] = rtid(basicPool[1], 'ZombieTypes')
        basicPool[2] = rtid(basicPool[2], 'ZombieTypes')
        basicPool[3] = rtid(basicPool[3], 'ZombieTypes')
        let table = document.createElement('table');
        table.style.width = '50%';
        table.style.margin = '0 auto'; // Center horizontally
        function addRow(cellType, text) {
            let row = document.createElement('tr'); // Create a new row
            let cell = document.createElement(cellType); // Create a new cell
            cell.textContent = text; // Set the cell's text content
            row.appendChild(cell); // Append the cell to the row
            table.appendChild(row); // Append the row to the table
        }



        function customList() {
            let levelPool = level.objects[3].objdata.ZombiePool;
            levelPool = [];
            levelPool.push(...basicPool);
            let div1 = document.getElementById('div1');
            if (document.getElementById('customList').checked == false) {
                div1.removeChild(document.getElementById('selectTag'));
                table.innerHTML = '';
                div1.removeChild(table);
                levelPool.push(...sample(specials, randint(2, 4)));
                if (stage == 'Pirate') {
                    levelPool.push(...sample(flyingUnits, randint(1, 3)))
                }
                for (let i = 0; i < levelPool.length; i++) {
                    levelPool[i] = rtid(levelPool[i], 'ZombieTypes');
                }
                level.objects[3].objdata.ZombiePool = levelPool;
                return;
            }
            let select = createOptions(specials);
            select.id = 'selectTag';
            let option = document.createElement('option');
            option.value = "";
            option.textContent = "-";
            option.defaultSelected = true; // Default selected
            option.hidden = true; // Hidden
            select.insertBefore(option, select.firstChild);
            select.oninput = function () {
                addRow('td', select.value);
                switch (select.value) {
                    case 'piano':
                        levelPool[0] = rtid('cowboy', 'zombieTypes')
                        levelPool[1] = rtid('cowboy_armor1', 'zombieTypes')
                        levelPool[2] = rtid('cowboy_armor2', 'zombieTypes')
                        levelPool[3] = rtid('cowboy_armor4', 'zombieTypes')
                        break;
                    case 'dark_king':
                        levelPool[0] = rtid('dark', 'zombieTypes')
                        levelPool[1] = rtid('dark_armor1', 'zombieTypes')
                        levelPool[2] = rtid('dark_armor2', 'zombieTypes')
                        levelPool[3] = rtid('dark_armor3', 'zombieTypes')
                        break;
                    default:
                        break;
                }
                levelPool.push(rtid(select.value, 'ZombieTypes'));
                level.objects[3].objdata.ZombiePool = levelPool;
            }
            //let basicPool = pool.toSpliced(4,pool.length);
            div1.appendChild(select);
            div1.appendChild(table);
        }


        function choice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function sample(arr, k) {
            let result = [];
            for (let i = 0; i < k; i++) {
                let randIndex = Math.floor(Math.random() * arr.length);
                result.push(arr[randIndex]);
                arr.splice(randIndex, 1);
            }
            return result;
        }

        function randint(min, max) {
            if (max < min) {
                [min, max] = [max, min]; // Swap min and max if max is less than min
            }
            // If min and max are equal, return that value
            if (min === max) {
                return min;
            }
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function coinFlip() {
            return Math.random() >= 0.5;
        }

        var level = new Object();
        var objects = new Array();
        var objdata = new Object();
        var waveManager = new Object();
        let escalation = new Object();

        let nonAmbush = ['West', 'Modern', 'Summer', 'Eighties']
        function waveArray() {
            let emptyWave = [];
            let waveOfEmptyWaves = [];
            for (let i = 1; i < total + 1; i++) {
                if (nonAmbush.includes(stage)) { waveOfEmptyWaves.push(emptyWave); continue; }
                if (i % interval == 0) {
                    waveOfEmptyWaves.push([rtid(`wave${i}ambush`, '.')]);
                    ambush(i);
                    if (['Dark', 'Iceage'].includes(stage)) { waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.')) }
                }
                else if (randint(1, 3) == 3) {
                    waveOfEmptyWaves.push([rtid(`wave${i}ambush`, '.')]);
                    ambush(i);
                    if (['Dark', 'Iceage'].includes(stage)) { waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.')) }
                }
                else waveOfEmptyWaves.push(emptyWave);
            }
            return waveOfEmptyWaves;
        }

        function dinoStage() {
            let k;
            // Extend switch to handle cases beyond 4 flags
            switch (flags) {
                case 1: k = randint(1, 2); break;
                case 2: k = randint(2, 3); break;
                case 3: k = randint(3, 5); break;
                case 4: k = 5; break;
                default: k = 5; // For any flags greater than 4, set k to the max 5 dinos
            }

            // Select dinos from the pool
            let dinos = sample(["raptor", "ptero", "stego", "tyranno", "ankylo"], k);

            // Create DinoWaveActionProps for each row (5 rows) and for the selected dinos
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < dinos.length; j++) {
                    append0({ "DinoRow": i, "DinoType": dinos[j] }, 'DinoWaveActionProps', `${dinos[j]}${i}`);
                }
            }

            // Initialize the waves
            var waveOfEmptyWaves = [];
            for (let i = 1; i <= total; i++) {
                var emptyWave = [];

                // Dino ambush logic for every interval-th wave and random waves
                if (i % interval === 0 || randint(1, 3) === 3) {
                    for (let j = 0; j < getViolence(i); j++) {
                        emptyWave.push(`${rtid(choice(dinos) + randint(0, 4), '.')}`);
                    }
                }

                // Add the empty wave to the wave list
                waveOfEmptyWaves.push(emptyWave);
            }

            return waveOfEmptyWaves;
        }



        function getViolence(wave) {
            if (wave < 3) {
                return 1;
            } else if (wave < 6) {
                return randint(1, 2);
            } else if (wave < 10) {
                return randint(2, 3);
            } else if (wave < 16) {
                return randint(3, 5);
            }
            else return randint(3, 7);
        }

        // Define cap values for normal difficulties
        // Set default cap values for easier difficulties (normal levels)
        let capStartingPoints = randint(500+difficulty, 500 * difficulty);  // Default scaling for normal difficulties
        let capPointIncrement = randint(300+difficulty, 600 * difficulty);    // Default point increment for normal difficulties

        // Determine the base values for escalation (default for normal levels)
        let baseStartingPoints = randint(1, difficulty <= 3 ? 4 : 10) * 25;
        let basePointIncrement = randint(1, difficulty <= 3 ? 2 : 7) * 25;

        // If difficulty is hard (threshold 4 or above), apply more aggressive scaling
        if (difficulty > 3) {
            capStartingPoints = randint(1000+difficulty, 1000 * difficulty);  // Aggressive scaling for hard levels
            capPointIncrement = randint(1000+difficulty, 3000 * difficulty);    // Aggressive point increment scaling for hard levels

            baseStartingPoints = randint(4, 12) * 100;  // Higher base values for hard difficulties
            basePointIncrement = randint(2, 10) * 100;  // Higher increments for hard difficulties
        }

        // Cap the values for easier difficulties, progressively less restrictive for harder ones
        let cappedStartingPoints = (difficulty <= 3) ? Math.min(baseStartingPoints, capStartingPoints) : baseStartingPoints;
        let cappedPointIncrement = (difficulty <= 3) ? Math.min(basePointIncrement, capPointIncrement) : basePointIncrement;

        console.log("Capped Starting Points:", cappedStartingPoints);
        console.log("Capped Point Increment:", cappedPointIncrement);

        // Adjust plant food spawn rate based on difficulty
        let plantfoodScaleFactor = difficulty <= 3 ? 1 / difficulty : difficulty / 1.5;  // Default scaling
        let plantfoodToSpawnCount = Math.max(1, Math.floor(4 / plantfoodScaleFactor));  // Ensure minimum of 1 plant food

        // For hard levels, increase plant food count by 2 if there are at least 3 plant foods
        if (difficulty > 3 && plantfoodToSpawnCount >= 3) {
            plantfoodToSpawnCount = Math.min(10,difficulty);
        }

        console.log("Plantfood To Spawn:", plantfoodToSpawnCount);

        // Assign properties to escalation
        escalation.FlagCount = flags;
        escalation.WavesPerFlag = interval;
        escalation.PlantfoodToSpawnCount = plantfoodToSpawnCount;  // Adjusted spawn count
        escalation.StartingPoints = cappedStartingPoints;
        escalation.PointIncrementPerWave = cappedPointIncrement;
        escalation.WaveManagerProps = "RTID(WaveManager@CurrentLevel)";
        escalation.ZombiePool = pool;





        var modules = [];

        function append(objdata, objclass, alias) {
            let obj = new Object();
            if (!(alias === undefined)) {
                obj.aliases = [alias];
                modules.push(`RTID(${alias}@.)`);
            }
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        function append0(objdata, objclass, alias) {
            let obj = new Object();
            obj.aliases = [alias];
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        modules.push("RTID(StandardIntro@LevelModules)");
        modules.push("RTID(ZombiesDeadWinCon@LevelModules)");
        modules.push("RTID(DefaultZombieWinCondition@LevelModules)");
        if (coinFlip()) { modules.push(`RTID(${stage}Mowers@LevelModules)`) };
        if (stage !== 'Dark' || stage !== 'Summer') { modules.push("RTID(DefaultSunDropper@LevelModules)") };

        objdata.StartingSun = randint(1, 4) * 25;
        objdata.Description = "Inszanity on a next level";
        objdata.Loot = "RTID(DefaultLoot@LevelModules)";
        objdata.Modules = modules;
        objdata.Name = choice(["Inzanity -", "Inzanity supreeme - ", "A Henry hell - ", "Planktontip : use winter mellon -", "This is not endless - "]) + stage + " -" + difficultyText + " Difficulty " ;
        if (difficulty > 2) {
            if (stage === "Iceage") {
                objdata.StageModule = `RTID(${stage}VeteranStage@LevelModules)`;
                objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`, `MiniGame_MiniBoss`])
            }
            else {
                objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
            }

        } else {
            objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
        }
        if (stage === 'Modern') {
            objdata.ResourceGroupNames = [
                "DelayLoad_Background_Beach",
                "DelayLoad_Background_Beach_Compressed",
                "Tombstone_Dark_Special",
                "Tombstone_Dark_Effects"
            ]
        }



        waveManager.FlagWaveInterval = interval;
        waveManager.WaveCount = total;
        waveManager.SuppressFlagZombie = false;

        append(objdata, 'LevelDefinition');
        append({ "SelectionMethod": "chooser" }, "SeedBankProperties", "SeedBank");
        append({}, "WaveManagerModuleProperties", "NewWaves");
        append(escalation, "LevelEscalationModuleProperties", "Escalation");


        if (stage == 'Dino') { waveManager.Waves = dinoStage() }
        else waveManager.Waves = waveArray();


        append(waveManager, "WaveManagerProperties", "WaveManager");

        level.objects = objects;
        level.version = 1;

        let occupied = new Set();

        switch (stage) {
            case 'Egypt':
                chessboard(2, 8, 'gravestone_egypt');
                break;
            case 'Modern':
                chessboard(2, 8, ['goldtile','gravestone_tutorial','surfboard', 'gravestoneSunOnDestruction','bufftile_attack','bufftile_speed','bufftile_shield',]);
                break;
            case 'Pirate':
                append({ "PlankRows": sample([0, 1, 2, 3, 4], randint(1, 5)).sort() }, "PiratePlankProperties", "PiratePlanks");
                pool.push(...sample(flyingUnits, randint(2, 4)));
                break;
            case 'West':
                railCarts();
                break;
            case 'Summer':
                let summerGrids = ["fireworks", 'speaker'];
                var InitialGridItemPlacements = [];
                for (let i = 0; i < summerGrids.length; i++) {
                    InitialGridItemPlacements.push(...powertileBoard(0, 4, summerGrids[i], randint(1, 3)));
                }
                var obj = new Object();
                obj.InitialGridItemPlacements = InitialGridItemPlacements;
                append(obj, 'InitialGridItemProperties', 'GI')
                break;
            case 'Future':
                let diceRoll = randint(1, 3); // Random number of power tiles
                let latinPower = ['alpha', 'beta', 'gamma', 'delta'];
                let strPower = 'powertile_';

                // Pick random latin letters for power tiles
                latinPower = sample(latinPower, diceRoll);

                // Buff tile types
                let latinBuff = ['attack', 'speed', 'shield'];
                let strBuff = 'bufftile_';
                let diceRollBuff = randint(1, 2);
                latinBuff = sample(latinBuff, diceRollBuff);

                // Combined grid placements for both power and buff tiles
                var InitialGridItemPlacements = [];

                // Iterate and place both power tiles and buff tiles
                for (let i = 0; i < latinPower.length; i++) {
                    // Power tile placement
                    InitialGridItemPlacements.push(...powertileBoard(0, 4, strPower + latinPower[i], randint(2, 5)));

                    // Buff tile placement at the same position
                    if (i < latinBuff.length) {
                        InitialGridItemPlacements.push(...bufftileBoard(0, 4, strBuff + latinBuff[i], randint(2, 5)));
                    }
                }

                // Single object to store both power and buff tile placements
                var obj = new Object();
                obj.InitialGridItemPlacements = InitialGridItemPlacements;

                // Append to the 'GI' module just once
                append(obj, 'InitialGridItemProperties', 'GI');
                break;

            case 'Dark':
                chessboard(2, 8, ['gravestone_dark', 'gravestone_dark', 'gravestoneSunOnDestruction']);
                break;
            case 'Beach':
                let columns = [9, 8, 7, 6, 5, 4];
                let index = randint(0, 5);

                // Add Initial Tide setup
                append({
                    "StartingWaveLocation": columns[index],  // Random column for the tide to start
                    "ShowTideMarker": true                   // Show the tide marker
                }, "TideProperties", "InitialTide");

                // Add beach grid items (e.g., surfboard and lilypad) for visual and gameplay elements
                chessboard(3, 6, ['surfboard', 'lilypad'], randint(2, 4));

                break;
            case 'Iceage':
                chessboard(3, 7, ['slider_up', 'slider_down'], randint(4, 5));
                break;
            case 'Dino':
                chessboard(3, 7, ['crater', 'tar', 'rock'], randint(3, 7));
                break;
            case 'Eighties':
                chessboard(3, 7, ['eightiesarcadecabinet', 'bufftile_shield', 'speaker'], randint(2, 4));
                break;
            case 'LostCity':
                chessboard(0, 5, ['goldtile', 'goldtile', 'goldtile', 'gravestone_lostcity', 'boulder_trap_falling_forward', 'flame_spreader_trap'], randint(1, 7));
            default:
                break;
        }

        for (let i = 0; i < pool.length; i++) {
            pool[i] = `RTID(${pool[i]}@ZombieTypes)`;
        }

        window.onload = function () {
            let filename = localStorage.getItem('filename');
            let levelnum = localStorage.getItem('levelnum');
            let selectedStage = localStorage.getItem('stage');

            let stageSelect = document.getElementById('stage');
            let select = document.getElementById('filename');
            if (filename !== null) {
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === filename) {
                        select.selectedIndex = i;
                        break;
                    }
                }
            }
            if (selectedStage !== null) {
                for (let i = 0; i < stageSelect.options.length; i++) {
                    if (stageSelect.options[i].value === selectedStage) {
                        stageSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            let num = document.getElementById('levelnum');
            if (levelnum !== null) {
                num.value = levelnum;
            }
        }

        // Save the selected values and reload the page
        function reload() {
            let num = document.getElementById('levelnum');
            let filename = document.getElementById('filename');
            let stageElement = document.getElementById('stage');
            localStorage.setItem('levelnum', num.value);
            let selectedFilename = filename.options[filename.selectedIndex].value;
            let selectedStage = stageElement.options[stageElement.selectedIndex].value;
            localStorage.setItem('filename', selectedFilename);
            localStorage.setItem('stage', selectedStage);
            location.reload();
        }




        // Debug function to find index by alias
        function findIndexWithAlias(objects, targetAlias) {
            const index = objects.findIndex(obj =>
                obj.aliases && Array.isArray(obj.aliases) && obj.aliases.includes(targetAlias)
            );
            console.log(`findIndexWithAlias(${targetAlias}): ${index}`);
            return index;
        }

        // Debug function to find index by class
        function findIndexWithClass(objects, targetClass) {
            const index = objects.findIndex(obj => obj.objclass === targetClass);
            console.log(`findIndexWithClass(${targetClass}): ${index}`);
            return index;
        }

        function chessboard(start, end, typeName, num = randint(0, 20)) {
            let grids = [];
            
            while (grids.length < num) {
                let i = randint(0, 4);  // Row (Y-coordinate)
                let j = randint(start, end);  // Column (X-coordinate)
                let pos = { "GridX": j, "GridY": i };
                let posStr = JSON.stringify(pos);

                if (!occupied.has(posStr)) {
                    occupied.add(posStr);

                    // Iceage sliders (Frostbite Caves)
                    if (stage === 'Iceage') {
                        if (i === 0) {
                            grids.push({ ...pos, "TypeName": 'slider_down' });  // Iceage Slider Down
                        } else if (i === 4) {
                            grids.push({ ...pos, "TypeName": 'slider_up' });  // Iceage Slider Up
                        }
                    }

                    // Modern sliders and regular items (Modern Day)
                    else if (stage === 'Modern') {
                        let randomType = Math.random();  // Random value for slider or regular item

                        if (randomType < 0.5) {  // 50% chance to place sliders
                            if (i === 0) {
                                grids.push({ ...pos, "TypeName": 'slider_down_modern' });  // Modern Slider Down
                            } else if (i === 4) {
                                grids.push({ ...pos, "TypeName": 'slider_up_modern' });  // Modern Slider Up
                            } else {
                                grids.push({ ...pos, "TypeName": choice(typeName) });  // Regular item in Modern
                            }
                        } else {
                            grids.push({ ...pos, "TypeName": choice(typeName) });  // Regular grid item
                        }
                    }

                    // If not Iceage or Modern, use provided typeName
                    else if (Array.isArray(typeName)) {
                        grids.push({ ...pos, "TypeName": choice(typeName) });
                    } else {
                        grids.push({ ...pos, "TypeName": typeName });
                    }
                }
            }

            // Finalize grid placements
            let objdata = new Object();
            objdata.InitialGridItemPlacements = grids;
            append(objdata, "InitialGridItemProperties", "GI");
        }








        function powertileBoard(start, end, typeName, num) {
            let grids = [];
            while (grids.length < num) {
                let i = randint(0, 4);  // Random Y between 0 and 4 (rows)
                let j = randint(start, Math.min(end, 7));  // X capped at 7
                if (grids.length < num) {
                    let pos = { "GridX": j, "GridY": i };
                    grids.push({ ...pos, "TypeName": typeName });  // Allowing overlap
                }
            }
            return grids;
        }

        // Buff tile spawns on the far edge, always at x = 8
        function bufftileBoard(start, end, typeName, num) {
            let grids = [];
            while (grids.length < num) {
                let i = randint(0, 3);  // Random Y between 0 and 3 (rows)
                let j = 8;  // Always spawn at x = 8
                if (grids.length < num) {
                    let pos = { "GridX": j, "GridY": i };
                    grids.push({ ...pos, "TypeName": typeName });  // Allowing overlap
                }
            }
            return grids;
        }

        function railCarts() {
            let objdata = new Object();
            objdata.RailcartType = "railcart_cowboy";
            let rails = [];
            let carts = [];
            for (let i = 0; i < 8; i++) {
                var diceRoll = randint(1, 6);
                var rows = sample([0, 1, 2, 3, 4], 2);
                var end = Math.max(...rows);
                var start = Math.min(...rows);

                switch (diceRoll) {
                    case 1:
                    case 6:
                        continue;
                    case 2:
                        rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                        carts.push({ "Column": i, "Row": randint(0, 4) });
                        break;
                    case 3:
                        rails.push({ "RowEnd": end, "RowStart": start, "Column": i });
                        carts.push({ "Column": i, "Row": randint(start, end) });
                        break;
                    case 4:
                        rails.push({ "RowEnd": 4, "RowStart": 3, "Column": i });
                        rails.push({ "RowEnd": 1, "RowStart": 0, "Column": i });
                        carts.push({ "Column": i, "Row": randint(3, 4) });
                        carts.push({ "Column": i, "Row": randint(0, 1) });
                        break;
                    case 5:
                        rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                        carts.push({ "Column": i, "Row": start });
                        carts.push({ "Column": i, "Row": end });
                        break;
                    default:
                        break;
                }
            }
            objdata.RailcartType = "railcart_cowboy";
            objdata.Rails = rails;
            objdata.Railcarts = carts;
            append(objdata, "RailcartProperties", "CowboyRails");
        }



        /*
        {"aliases":["Sandstorm1_C1"],
        "objclass": "StormZombieSpawnerProps",
        "objdata": {
        objdata.AdditionalPlantfood = "0",
        objdata.Type = "sandstorm",
        objdata.ColumnStart = 1,
        objdata.ColumnEnd = 1,
        objdata.TimeBetweenGroups = 0.5,
        objdata.GroupSize = 1,
            "Zombies": [
                {"Type": "RTID(tutorial@ZombieTypes)"},
                {"Type": "RTID(tutorial@ZombieTypes)"}
            ]
        }},
        */
        function stormAmbush(wave, type, violence) {
            let pool = [];
            var basic, imp, conhead, buckethead, brickhead, garg;
            switch (type) {
                case 'sand':
                    basic = "mummy";
                    imp = "egypt_imp"
                    conehead = "mummy_armor1";
                    buckethead = "mummy_armor2";
                    brickhead = "mummy_armor4";
                    garg = "egypt_gargantuar";
                    break;
                case 'pirate':
                    imp = "pirate_imp"
                    garg = "pirate_gargantuar";
                    break;
                case 'future':
                    imp = "future_imp"
                    garg = "future_gargantuar";
                    break;
                case 'cowboy':
                    imp = "west_bullrider"
                    garg = "cowboy";
                    break;
                case 'dino':
                    imp = "dino_imp"
                    garg = "dino_gargantuar";
                    break;
                case 'beach':
                    imp = "beach_imp"
                    garg = "beach_gargantuar";
                    break;
                case 'dark':
                    basic = { "Type": "RTID(dark@ZombieTypes)" };
                    conehead = { "Type": "RTID(dark_armor1@ZombieTypes)" };
                    buckethead = { "Type": "RTID(dark_armor2@ZombieTypes)" };
                    brickhead = { "Type": "RTID(dark_armor3@ZombieTypes)" };
                    imp = { "Type": "RTID(dark_imp@ZombieTypes)" };
                    garg = { "Type": "RTID(dark_gargantuar@ZombieTypes)" };
                    break;
                case 'snow':
                    basic = "iceage";
                    conehead = "iceage_armor1";
                    buckethead = "iceage_armor2";
                    brickhead = "iceage_armor3";
                    imp = "iceage_imp";
                    garg = "iceage_gargantuar";
                    break;
                case 'eighties':
                    imp = "eighties_imp";
                    garg = "eighties_gargantuar";
                    break;
                case 'summer':
                    basic = "summer_basic";
                    conehead = "summer_armor1";
                    buckethead = "summer_armor2";
                    brickhead = "eighties_armor4";
                    imp = "summer_imp"
                    garg = "summer_gargantuar";
                    break;
                default:
                    imp = "zcorp_imp"
                    garg = "zcorp_gargantuar";;
                    break;
            }
            let start = 0;
            let num = 0;
            let end = 0;

            switch (violence) {
                case 0:
                    pool = [basic];
                    start = 6;
                    end = 8;
                    num = 1;
                    break;
                case 1:
                    pool = [basic, imp, conehead];
                    start = 5;
                    end = 7;
                    num = randint(1, difficulty);
                    break;
                case 2:
                    pool = [basic, imp, imp, conehead];
                    start = 4;
                    end = 7;
                    num = randint(2, difficulty + 1);
                    break;
                case 3:
                    pool = [conehead, conehead, imp, buckethead, garg];
                    start = 3;
                    end = 6;
                    num = randint(3, difficulty + 2);
                    break;
                case 4:
                    pool = [buckethead, basic, buckethead, brickhead, brickhead, brickhead, garg];
                    start = 2;
                    end = 6;
                    num = randint(4, difficulty + 4);
                    break;
            }
            let objdata = new Object();
            objdata.AdditionalPlantfood = "0",
                objdata.Type = `${type}storm`,
                objdata.ColumnStart = start,
                objdata.ColumnEnd = end,
                objdata.TimeBetweenGroups = 0.5,
                objdata.GroupSize = 1;
            let temp = [];
            for (let i = 0; i < num; i++) {
                temp.push({ "Type": `RTID(${choice(pool)}@ZombieTypes)` });
            }
            objdata.Zombies = temp;
            if (type == 'dark') {
                return pool;
            }
            append0(objdata, "StormZombieSpawnerProps", `wave${wave}ambush`);
        }

        /*
        "GroupSize": 3,
        "SwashbucklerCount": 3,
        "TimeBetweenGroups": 1
        */

        function raidingParty(wave, violence) {
            let objdata = new Object();
            let times = [1.5, 1.25, 1.0, 0.75, 0.5, 0.25, 0.1];

            objdata.GroupSize = randint(1, 3);
            switch (violence) {
                case 0:
                    objdata.TimeBetweenGroups = times[0];
                    objdata.SwashbucklerCount = 1;
                    break;
                case 1:
                    objdata.TimeBetweenGroups = times[randint(1, 4)];
                    objdata.SwashbucklerCount = randint(2, difficulty);
                    break;
                case 2:
                    objdata.TimeBetweenGroups = times[randint(3, 5)];
                    objdata.SwashbucklerCount = randint(3, difficulty + 2);
                    break;
                case 3:
                    objdata.TimeBetweenGroups = times[randint(5, 6)];
                    objdata.SwashbucklerCount = randint(9, difficulty + 12);
                    break;
                case 4:
                    objdata.TimeBetweenGroups = times[6];
                    objdata.SwashbucklerCount = randint(10, difficulty + 13);
                    break;
            }
            append0(objdata, 'RaidingPartyZombieSpawnerProps', `wave${wave}ambush`);
        }

        function rain(wave, violence) {
            var num = 0;
            var start = 0;
            var end = 0;
            var time = 0;
            switch (violence) {
                case 0:
                    time = 1.0;
                    start = 6;
                    end = 8;
                    num = randint(1, 2);
                    break;
                case 1:
                    time = 0.75;
                    start = 5;
                    end = 7;
                    num = randint(2, 4);
                    break;
                case 2:
                    time = 1.5;
                    start = 3;
                    end = 6;
                    num = randint(4, 7);
                    break;
                case 3:
                    time = 1.25;
                    start = 3;
                    end = 6;
                    num = randint(6, 9);
                    break;
                case 4:
                    time = 1.1;
                    start = 2;
                    end = 6;
                    num = randint(8, 14);
                    break;
            }
            let objclass, name, message;
            switch (stage) {
                case 'Future':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'future_imp'
                    message = choice(['Bot Swarm!', 'Fallen Technologie!'])
                    break;
                case 'LostCity':
                    objclass = 'ParachuteRainZombieSpawnerProps'
                    name = 'lostcity_lostpilot'
                    message = 'Parachute Rain!'
                    break;
                case 'Summer':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'summer_imp'
                    message = 'Hot Dogs!'
                    break;

                default:
                    if (Math.random() < 0.2) {
                        objclass = 'ParachuteRainZombieSpawnerProps'
                        name = 'zcorp_helpdesk'
                        message = 'inzanity support!'
                    }
                    break;
            }
            let objdata = new Object();
            objdata.ColumnStart = start;
            objdata.ColumnEnd = end;
            objdata.SpiderCount = num;
            objdata.TimeBetweenGroups = `${time}`;
            objdata.ZombieFallTime = `${time}`;
            objdata.SpiderZombieName = name;
            objdata.WaveStartMessage = message;
            append0(objdata, objclass, `wave${wave}ambush`);
        }

        function graveSpawn(wave, violence) {
            let num;
            switch (violence) {
                case 0: num = randint(1, 2); break;
                case 1: num = randint(2, 4); break;
                case 2: num = randint(2, 6); break;
                case 3: num = randint(4, 8); break;
                case 4: num = randint(7, 12); break;
            };
            let sun = 0;
            let regular = 0;
            while (num !== 0) {
                let diceRoll = randint(1, num);
                regular += diceRoll;
                num -= diceRoll;
                diceRoll = randint(1, num);
                sun += diceRoll;
                num -= diceRoll;
            }
            let objdata = new Object();
            objdata.GravestonePool = [
                { "Count": regular, "Type": "RTID(gravestone_dark@GridItemTypes)" },
                { "Count": sun, "Type": "RTID(gravestoneSunOnDestruction@GridItemTypes)" },
                { "Count": sun, "Type": "RTID(gravestonePlantFoodOnDestruction@GridItemTypes)" }
            ]
            objdata.SpawnEffectAnimID = 'POPANIM_EFFECTS_TOMBSTONE_DARK_SPAWN_EFFECT';
            objdata.SpawnPositionsPool = [{ "mX": 1, "mY": 0 }, { "mX": 1, "mY": 1 }, { "mX": 1, "mY": 2 }, { "mX": 1, "mY": 3 }, { "mX": 1, "mY": 4 }, { "mX": 2, "mY": 0 }, { "mX": 2, "mY": 1 }, { "mX": 2, "mY": 2 }, { "mX": 2, "mY": 3 }, { "mX": 2, "mY": 4 }, { "mX": 3, "mY": 0 }, { "mX": 3, "mY": 1 }, { "mX": 3, "mY": 2 }, { "mX": 3, "mY": 3 }, { "mX": 3, "mY": 4 }, { "mX": 4, "mY": 0 }, { "mX": 4, "mY": 1 }, { "mX": 4, "mY": 2 }, { "mX": 4, "mY": 3 }, { "mX": 4, "mY": 4 }, { "mX": 5, "mY": 0 }, { "mX": 5, "mY": 1 }, { "mX": 5, "mY": 2 }, { "mX": 5, "mY": 3 }, { "mX": 5, "mY": 4 }, { "mX": 6, "mY": 0 }, { "mX": 6, "mY": 1 }, { "mX": 6, "mY": 2 }, { "mX": 6, "mY": 3 }, { "mX": 6, "mY": 4 }, { "mX": 7, "mY": 0 }, { "mX": 7, "mY": 1 }, { "mX": 7, "mY": 2 }, { "mX": 7, "mY": 3 }, { "mX": 7, "mY": 4 }, { "mX": 8, "mY": 0 }, { "mX": 8, "mY": 1 }, { "mX": 8, "mY": 2 }, { "mX": 8, "mY": 3 }, { "mX": 8, "mY": 4 }];
            objdata.SpawnSoundID = 'Play_Zomb_Egypt_TombRaiser_Grave_Rise';
            append0(objdata, "SpawnGravestonesWaveActionProps", `wave${wave}ambush`);
        }

        function ambush(wave) {
            if (stage === 'West') {
                return;
            }
            let violence;
            if (wave < 3) {
                violence = 0;
            } else if (wave < 6) {
                violence = 1;
            } else if (wave < 10) {
                violence = 2;
            } else if (wave < 16) {
                violence = 3;
            }
            else violence = 4;
            switch (stage) {
                case 'Iceage':
                    ambushRoulette(wave, violence);
                    break;
                case 'Egypt':
                    stormAmbush(wave, 'sand', violence);
                    break;
                case 'Pirate':
                    raidingParty(wave, violence);
                    break;
                case 'Future':
                case 'LostCity':
                    rain(wave, violence);
                    break;
                case 'Dark':
                    ambushRoulette(wave, violence);
                    break;
                case 'Beach':
                    let columns = [9, 8, 7, 6, 5, 4, 3, 2, 1];
                    let index = randint(0, columns.length - 1);

                    // Random zombie selection based on violence level
                    let zombies = ['beach', 'beach_imp', 'beach_fem_armor1', 'beach_fem']; // Replace with actual zombie types
                    let zombieCount = randint(1, 3) + violence; // Randomize number of zombies based on violence
                    let selectedZombies = [];

                    for (let i = 0; i < zombieCount; i++) {
                        let zombieIndex = randint(0, zombies.length - 1);
                        selectedZombies.push(zombies[zombieIndex]);
                    }

                    // Apply tidal changes for specific waves
                    append0({
                        "TidalChange": {
                            "ChangeAmount": columns[index],  // Change tide based on random column
                            "ChangeType": "absolute"         // Absolute change type
                        },
                        "Zombies": selectedZombies          // Spawn the randomized zombies with tide changes
                    }, 'TidalChangeWaveActionProps', `wave${wave}ambush`);

                    break;
                default:
                    break;
            }
        }


        function necromancy(wave, violence) {
            let objdata = new Object();
            objdata.AdditionalPlantfood = '0';
            objdata.GridTypes = ["RTID(gravestone_dark@GridItemTypes)", "RTID(gravestoneSunOnDestruction@GridItemTypes)"];
            objdata.WaveStartMessage = '[WARNING_GRAVESTONE_SPAWN]';
            objdata.ZombieSpawnWaitTime = '1';
            objdata.Zombies = stormAmbush(wave, 'dark', violence);
            append0(objdata, "SpawnZombiesFromGridItemSpawnerProps", `wave${wave}ambushExtra`);
        }

        function winds(wave, violence) {
            let winds = [{ "Direction": "left", "Row": "0" }, { "Direction": "left", "Row": "1" }, { "Direction": "left", "Row": "2" }, { "Direction": "left", "Row": "3" }, { "Direction": "left", "Row": "4" }, { "Direction": "right", "Row": "0" }, { "Direction": "right", "Row": "1" }, { "Direction": "right", "Row": "2" }, { "Direction": "right", "Row": "3" }, { "Direction": "right", "Row": "4" }];
            let objdata = new Object();
            let temp = [];
            switch (violence) {
                case 0: temp = sample(winds, randint(1, 2)); break;
                case 1: temp = sample(winds, randint(1, 4)); break;
                case 2: temp = sample(winds, randint(2, 6)); break;
                case 3: temp = sample(winds, randint(3, 8)); break;
                case 4: temp = sample(winds, randint(4, 10)); break;
            }
            objdata.Winds = temp;
            append0(objdata, 'FrostWindWaveActionProps', `wave${wave}ambushExtra`)
        }

        function ambushRoulette(wave, violence) {
            let diceRoll;
            if (violence > 1) { diceRoll = randint(1, 3); }
            else diceRoll = randint(1, 2);
            switch (diceRoll) {
                case 1:
                    let violence1 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        graveSpawn(wave, violence1);
                    } else {
                        stormAmbush(wave, 'snow', violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambushExtra`);
                    break;

                case 2:
                    let violence2 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        necromancy(wave, violence2);
                    } else {
                        winds(wave, violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambush`);
                    break;

                case 3:
                    let violence3 = Math.max(0, violence - 5 + difficulty);
                    if (stage == 'Dark') {
                        graveSpawn(wave, violence3);
                        necromancy(wave, Math.max(0, violence - 5 + difficulty));
                    } else {
                        stormAmbush(wave, 'snow', Math.max(0, violence - 5 + difficulty));
                        winds(wave, violence);
                    }
                    break;

                default:
                    break;
            }

        }

    </script>
</body>

</html>