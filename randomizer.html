<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ2 level randomizer</title>
    <link rel="stylesheet" href="style.css">
    <script src="randombg.js"></script>
    <style>
        .level-preview {
            border: 2px solid #333;
            padding: 10px;
            width: 300px;
            margin: 10px;
        }
        .level-preview .variable {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        .variable-name {
            font-weight: bold;
        }
        .variable-value {
            text-align: right;
        }
    </style>
</head>

<body>
    <div id="snackbar">Some text some message..</div>
    <div id="div1" class="filename-container">
        <label> Options :</label>
        <select onchange="setMod(modOption.value)" name="mod" id="modOption">
            <option value="vnl">VNL</option>
            <option value="rfl">RFL</option>
        </select>

        <label>Filename: </label><select id="filename"></select>
        <input style="width: 40px;" value="1" type="number" min="1" max="40" id="levelnum">
        .json<br>
        <label>Stage: </label>
        <select id="stage"></select>
        <label>Custom list: </label>
        <input type="checkbox" onclick="customList()" id="customList">
        <br>
        <h2>Select Difficulty</h2>
        <div class="select-container">
            <label for="difficulty">Difficulty Level:</label>
            <select id="difficulty" name="difficulty" onchange="updateDifficultyText(this.value)">
                <option hidden defaultSelected>-</option>
                <option value="1">Easy</option>
                <option value="2">Normal</option>
                <option value="3">Inzane</option>
                <option value="4">CRAAAZY!</option>
                <option value="5">Johan</option>
            </select>
        </div><br>
    </div>
    
    <div class="filename-container">
        <h2>PvZ2 Level Preview</h2>
    
        <div id="levelPreview" class="inner-container">
            <!-- This is where the preview will appear -->
        </div>
        <button onclick="generatePreview()">Preview Variables</button><br>
        <button id="Copy" onclick="copyCode()">Copy</button>
        <p> or </p>
        <button id="buttonA" onclick="startDownload()">Download</button>
    </div>

    

    <h4><a id="home" href="index.html">Home page</a></h4>

    <script>
        let violence = 1;

        // Generate preview for level variables
        function generatePreview() {
            
            let previewContainer = document.getElementById('levelPreview');
            previewContainer.innerHTML = '';

            let variablesHTML = `

                <div class="inner-div">
                    <div class="variable-name">Special Pool</div>
                    <div class="variable-value">${pool.join(', ')}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Starting Points</div>
                    <div class="variable-value">${cappedStartingPoints}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Points Increment</div>
                    <div class="variable-value">${cappedPointIncrement}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Plant Food to Spawn</div>
                    <div class="variable-value">${plantfoodToSpawnCount}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Flags</div>
                    <div class="variable-value">${flags}</div>
                </div>`;

            previewContainer.innerHTML = variablesHTML;
        }
        let difficulty = localStorage.getItem('difficulty');
        let difficultyText = document.getElementById("difficulty").options[document.getElementById("difficulty").selectedIndex].text;
        if (localStorage.getItem('difficulty') != null){
            document.getElementById('difficulty').selectedIndex = localStorage.getItem('difficulty')
        }
        function updateDifficultyText(value){
            localStorage.setItem('difficulty',value);
            reload();
        }

        function copyCode() {
            const text = JSON.stringify(level, null, 2); // Converts the object to a formatted JSON string
            navigator.clipboard.writeText(text);
            snackbar("Level code copied.");
        }
        function snackbar(text){
            var x = document.getElementById("snackbar")
            x.textContent = text;
            // Add the "show" class to DIV
            x.className = "show";

            // After 3 seconds, remove the show class from DIV
            setTimeout(function () { x.className = x.className.replace("show", ""); reload();}, 3000);
        }

        function startDownload() {
            // Get the filename from the input fields
            let filename = document.getElementById('filename').value;
            filename += document.getElementById('levelnum').value + '.json';
            text = JSON.stringify(level, null, 2);
            filename = filename.toLowerCase();

            // Convert the level object to a JSON string
            let dataStr = text;

            // Create a Blob object from the data string
            let dataBlob = new Blob([dataStr], { type: 'application/json' });

            // Create a URL for the Blob object
            let url = URL.createObjectURL(dataBlob);

            // Create a link element
            let link = document.createElement('a');
            link.download = filename;
            link.href = url;

            // Append the link to the body
            document.body.appendChild(link);

            // Simulate a click on the link
            link.click();

            // Remove the link from the body
            document.body.removeChild(link);

            snackbar('Level downloaded.')


        }


        let mod = localStorage.getItem('mod');
        if (mod == null) { mod = 'vnl' }
        document.getElementById('modOption').value = mod;

        function setMod(mod) {
            localStorage.setItem('mod', mod);
            reload();
        }

        function rtid(str, module) {
            return `RTID(${str}@${module})`;
        }


        let interval = Math.min(15,randint(5,difficulty+1));
        let minWaves = 3;
        let maxWaves = 5;

        // Formula to calculate flags based on difficulty
        let flags =randint(3,5);

        // Calculate the total based on interval and flags
        let total = interval * flags;

        function extraSpecials() {
            switch (mod) {
                case 'rfl':
                    return [
                            "fire_ball","ice_ball","iceage_charred",
                            "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus", "beach_snorkel","roman_medusa","steam_furnace",
                            "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite", "beach_surfer","roman_healer","roman_shield_pair",
                            "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser", "pumpkin_scarecrow","roman_shield_pair",
                            "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler", "zcorp_racer_chair", "zcorp_consultant","eighties_breakdancer",
                            "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1","roman_ballista","eighties_mc",
                            "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "iceage_dodo_veteran", "iceage_hunter_veteran","eighties_glitter",
                            "eighties_arcade", "eighties_arcade_basic", "iceage_weaselhoarder_veteran", "iceage_chief", "iceage_chief_veteran","eighties_punk",
                            "eighties_boombox", "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry", "iceage_troglobite_basic", "modern_newspaper", "modern_balloon", "modern_allstar",
                            "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco", "dark_explorer", "explorer_veteran",
                            "lostcity_explorer", "barrelroller_explosive", "ghost_scare", "halloween_ghost", "future_protector_generator", "general_treadmill_phase2", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic",
                            "carnie_stiltwalker","carnie_firebreather","carnie_cannon","carnie_magician","carnie_imp_twins","harvest_outhouse","harvest_pitchfork","harvest_eggstealer","harvest_pterry","foodfight_gobbler_king",
                            "eighties_punk_veteran",
                            "eighties_breakdancer",
                            "eighties_arcade"
                        ];
                    break;
                default:
                    return [];
                    break;
            }
        }

        function extraStages() {
            switch (mod) {
                case 'rfl':
                    return ['Summer'];
                    break;

                default:
                    return [];
                    break;
            }
        }
        let specials = []
        switch (mod) {
            case 'rfl':
                specials = [
                    "fire_ball","ice_ball","iceage_charred",
                    "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus", "beach_snorkel","roman_medusa","steam_furnace",
                    "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite", "beach_surfer","roman_healer","roman_shield_pair",
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser", "pumpkin_scarecrow","roman_shield_pair",
                    "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler", "zcorp_racer_chair", "zcorp_consultant","eighties_breakdancer",
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1","roman_ballista","eighties_mc",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "iceage_dodo_veteran", "iceage_hunter_veteran","eighties_glitter",
                    "eighties_arcade", "eighties_arcade_basic", "iceage_weaselhoarder_veteran", "iceage_chief", "iceage_chief_veteran","eighties_punk",
                    "eighties_boombox", "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry", "iceage_troglobite_basic", "modern_newspaper", "modern_balloon", "modern_allstar",
                    "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco", "dark_explorer", "explorer_veteran",
                    "lostcity_explorer", "barrelroller_explosive", "ghost_scare", "halloween_ghost", "future_protector_generator", "general_treadmill_phase2", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic",
                    "carnie_stiltwalker","carnie_firebreather","carnie_cannon","carnie_magician","carnie_imp_twins","harvest_outhouse","harvest_pitchfork","harvest_eggstealer","harvest_pterry","foodfight_gobbler_king"
                ];
            default:
                specials = [
                    "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus",
                    "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser",
                    "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler",
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter",
                    "eighties_boombox", "dino_bully", "modern_newspaper", "modern_balloon", "modern_allstar",
                    "prospector", "west_bull", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco"
                ];
        }
        function createOptions(arr) {
            const selectElement = document.createElement('select');

            arr.forEach((value) => {
                const optionElement = document.createElement('option');
                optionElement.value = value;
                optionElement.textContent = value;
                selectElement.appendChild(optionElement);
            });

            return selectElement;
        }

        specials.push(...extraSpecials());
        let part ="harvest";
        let bots = ["steam_clockwork","iceage_dodo_veteran","hero_zmech","steam_mechanic","steam_repairimp","future_imp","future_protector_generator","future_gargantuar","mech_cone","disco_mech","future_protector","west_bull","west_bull_veteran"]
        let basics = ["tutorial","carnie","eighties_8bit","roman", "mummy", "pirate", "cowboy", "future", "dark", "beach", "beach_fem", "iceage", "lostcity", "eighties", "dino", "summer", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem", part,part,part,part, part,part,part,part, "steam_miner", "steam"];
        let imps = ["tutorial_imp", "egypt_imp", "pirate_imp", "future_imp", "dark_imp", "beach_imp", "iceage_imp", "lostcity_imp", "eighties_imp", "dino_imp", "steam_imp","zcorp_imp","zcorp_imp"];
        let gargs = ["egypt_gargantuar", "cowboy_gargantuar", "future_gargantuar", "dark_gargantuar", "beach_gargantuar", "iceage_gargantuar", "lostcity_gargantuar", "dino_gargantuar", "tutorial_gargantuar", "summer_gargantuar", "steam_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar"]
        let validArmor4 = ["tutorial","iceage","eighties","beach","zcorp", "mummy", "pirate", "cowboy", "future", "dino", "dark"]
        
        let flyingUnits = ["lostcity_bug_armor2", "lostcity_bug_armor1", "modern_balloon", "tutorial_balloon", "future_jetpack_veteran", "future_jetpack", "pelican", "cannon", "lostcity_bug", "summer_bug", "summer_bug_armor1", "summer_bug_armor2", "future_jetpack_veteran", "spongebob_vi", "spongebob_vi_armor1", "spongebob_vi_armor2", "seagull", "steam_inventor"];
        let stage = ["Modern", "Egypt", "Pirate", "West", "Future", "Beach", "Iceage", "LostCity", "Eighties", "Dino","Harvest"];
        stage.push(...extraStages());
        let stageBtn = localStorage.getItem('selectedStage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let select = document.getElementById('filename');
            let txt = stage[i];
            if (i == 2) { txt = 'Cowboy' }
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        function linearSearchAndRemove(array, element) {
            let index = array.indexOf(element);
            if (index !== -1) {
                array.splice(index, 1);
            }
            return array;
        }



        stage.unshift('random');
        let select = document.getElementById('stage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let txt = stage[i];
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        select.addEventListener('change', function () {
            localStorage.setItem('selectedStage', this.value);
            reload();
        });
        stage.shift();
        if (stageBtn === 'random') {
            stage = choice(stage);
        }
        else stage = stageBtn;
        // Determine the max number of specials based on difficulty scaling
        let maxSpecials;
        if (difficulty === 1) { // Easy difficulty
            maxSpecials = randint(2, 4);  // 2-4 specials
        } else if (difficulty <= 3) { // Normal difficulty (2-3)
            maxSpecials = randint(10, 20);  // 10-20 specials
        } else if (difficulty <= 6) { // Insane difficulty (4-6)
            maxSpecials = randint(25, 35);  // 25-35 specials
        } else if (difficulty <= 9) { // Crazy difficulty (7-9)
            maxSpecials = randint(45, 60);  
        } else { // Johan difficulty (10+)
            maxSpecials = randint(80, specials.length);  // No limit (all specials)
        }
        // Scale the number of specials to pick based on difficulty, capped by maxSpecials
        let numSpecials = Math.min(randint(1, difficulty * 5), maxSpecials);

        // Select the actual specials based on the final number
        let pool = sample(specials, numSpecials);



        let minibossPool = [
            "miniboss_impfinity",
            "birthday_caketank",
            "hero_zmech",
            "hero_crystalskull",
            "feastivus_multplicity",
            "mashup_arcade",
            "mashup_arcade_cabinet_miniboss",
            "hero_electricboogaloo",
            "hero_armor1",
            "hero_armor2",
            "hero_flag",
            "hero_disco_mech",
            "hero_jetpack_disco",
            "hero_impfinity",
            "hero_neptuna",
            "hero_rustbolt",
            "hero_superbrainz",
            "hero_weaselhoarder",
            "galaxy_dodo",
            "hero_barrelroller",
            "hero_barrel",
            "hero_smash"
        ];

        // Special logic for difficulty higher than 40
        
        if (difficulty > 4) {
            pool.push("hero_zmech");
            if (Math.random()*10 <= 50) {  // 50% chance to use the miniboss pool
                pool = minibossPool;
            }
        }
        switch (stage) {
            case 'Modern':
                basics = ['tutorial'];
                break;
            case 'Iceage':
                basics = ['iceage'];
                pool.push("iceage_armor3");
                pool.push("iceage_dodo");
                break;
            case 'Dark':
                basics = ['dark'];
                pool.push("dark_armor3");
                break;
            case 'Pirate':
                if (coinFlip()) {
                    pool.push("zcorp_consultant");
                }
                break;
            default:
                // Handle any other cases if necessary
                break;
        }

        if (pool.includes("dino_bully_blue")) {
            basics = ['dino'];
            pool.push("dino_armor3");
        }
        if (pool.includes("ra")) {
            basics = ['mummy'];
        }
        if (pool.includes("iceage_hunter")) {
            pool.push("iceage_troglobite");
            pool.push("iceage_chief");
        }
        if (pool.includes("iceage_hunter_veteran")) {
            pool.push("iceage_troglobite_basic");
        }
        if (pool.includes("iceage_hunter_veteran")) {
            pool.push("iceage_troglobite_basic");
        }
        if (pool.includes("modern_allstar")) {
            pool.push("modern_superfanimp");
            if (coinFlip()) {
                pool.push("zcorp_racer_chair")
            }
        }
        if (stage === "Future") {
            if (coinFlip()) {
                pool.push("steam_repairimp");
                pool.push(...sample(bots, randint(2, Math.min(difficulty,bots.length))));
            }
            pool.push(...sample(bots, randint(2, Math.min(difficulty,bots.length))));
        }
        if (pool.includes("dark_king")) {
            basics = ['dark'];
        }


        // Check if the stage is 'Beach'
        if (stage == 'Beach') {
            basics = ['beach', 'beach_fem'];
            pool.push("beach_snorkel");

            // 50% chance to add "beach_fisherman"
            if (Math.random() < 0.5) {
                pool.push("beach_fisherman");
            }

            // Replace "dark_king" or "piano" with beach-themed characters
            pool = pool.map(item => {
                if (item === "dark_king") {
                    return "beach_octopus";
                } else if (item === "piano") {
                    return "beach_surfer";
                }
                return item;
            });
            if (stage == 'Dino') {
                basics = ['dino'];
                if (Math.random() < 0.5) {
                    pool.push("dino_imp");
                }
            }
        } 
        else if (pool.includes("piano")) {
            basics = ['cowboy'];
        }
        if (Math.random() < (0.3 * difficulty)) {
                pool.push(...sample(gargs, randint(0, 2)));  // Higher chance of adding Gargantuars
        }

        if (Math.random() < (0.5 * difficulty)) {
            pool.push(...sample(imps, randint(0, 3)));   // Higher chance of adding Imps
        }
        const jamers = [
            "eighties_punk",
            "eighties_punk_veteran",
            "eighties_glitter",
            "eighties_mc",
            "eighties_breakdancer",
            "eighties_arcade",
            "eighties_boombox",
            "eighties_gargantuar",
            "eighties_punk_8bit",
            "eighties_punk_veteran_8bit",
            "stpatrick_punk",
            "stpatrick_punk_punk",
            "eighties_glitter_8bit",
            "stpatrick_glitter",
            "stpatrick_glitter_pop",
            "eighties_mc_8bit",
            "eighties_breakdancer_8bit",
            "halloween_breakdancer",
            "stpatrick_breakdancer",
            "space_dancer",
            "space_dancer_8bit",
            "eighties_gargantuar_8bit",
            "stpatrick_gargantuar_metal",
            "eighties_boombox_8bit",
            "summer_boombox",
            "summer_boombox_ballad",
            "mashup_arcade",
            "mashup_arcade_spongebob"

        ];

        // Helper function to filter out conflicting zombies
        function filterConflictingZombies(selectedZombies) {
            const filtered = selectedZombies.filter(zombie => {
                const baseName = zombie.replace(/_8bit$/, ''); // Remove _8bit suffix to find the base
                const is8Bit = zombie.endsWith('_8bit');
                return !selectedZombies.some(selected => {
                    return (selected === baseName || selected === `${baseName}_8bit`) && selected !== zombie;
                });
            });
            return filtered;
        }

        // Main selection function
        function selectJamers(stage) {
            if (stage === 'Eighties') {
                let selectedJamers = sample(jamers, randint(6, jamers.length)); // Randomly select jamers
                
                // Filter the selected jamers to remove conflicts
                selectedJamers = filterConflictingZombies(selectedJamers);
                
                pool.push(...selectedJamers);
            }
        }
        selectJamers('Eighties');


        pool.unshift(choice(validArmor4) + '_armor4');
        pool.unshift(choice(basics) + '_armor2');
        pool.unshift(choice(basics) + '_armor1');
        pool.unshift(choice(basics));
        if (pool[0] == 'summer') {
            pool[0] = 'summer_basic';
        }
        let basicPool = pool.toSpliced(4, pool.length);
        basicPool[0] = rtid(basicPool[0], 'ZombieTypes')
        basicPool[1] = rtid(basicPool[1], 'ZombieTypes')
        basicPool[2] = rtid(basicPool[2], 'ZombieTypes')
        basicPool[3] = rtid(basicPool[3], 'ZombieTypes')
        let table = document.createElement('table');
        table.style.width = '50%';
        table.style.margin = '0 auto'; // Center horizontally


        function addRow(cellType, text) {
            let row = document.createElement('tr'); // Create a new row
            let cell = document.createElement(cellType); // Create a new cell
            cell.textContent = text; // Set the cell's text content
            row.appendChild(cell); // Append the cell to the row
            table.appendChild(row); // Append the row to the table
        }



        function customList() {
            let levelPool = level.objects[3].objdata.ZombiePool;
            levelPool = [];
            levelPool.push(...basicPool);
            let div1 = document.getElementById('div1');
            if (document.getElementById('customList').checked == false) {
                div1.removeChild(document.getElementById('selectTag'));
                table.innerHTML = '';
                div1.removeChild(table);
                levelPool.push(...sample(specials, randint(2, 4)));
                if (stage == 'Pirate') {
                    levelPool.push(...sample(flyingUnits, randint(1, 3)))
                }
                for (let i = 0; i < levelPool.length; i++) {
                    levelPool[i] = rtid(levelPool[i], 'ZombieTypes');
                }
                level.objects[3].objdata.ZombiePool = levelPool;
                return;
            }
            let select = createOptions(specials);
            select.id = 'selectTag';
            let option = document.createElement('option');
            option.value = "";
            option.textContent = "-";
            option.defaultSelected = true; // Default selected
            option.hidden = true; // Hidden
            select.insertBefore(option, select.firstChild);
            select.oninput = function () {
                addRow('td', select.value);
                switch (select.value) {
                    case 'piano':
                        levelPool[0] = rtid('cowboy', 'zombieTypes')
                        levelPool[1] = rtid('cowboy_armor1', 'zombieTypes')
                        levelPool[2] = rtid('cowboy_armor2', 'zombieTypes')
                        levelPool[3] = rtid('cowboy_armor4', 'zombieTypes')
                        break;
                    case 'dark_king':
                        levelPool[0] = rtid('dark', 'zombieTypes')
                        levelPool[1] = rtid('dark_armor1', 'zombieTypes')
                        levelPool[2] = rtid('dark_armor2', 'zombieTypes')
                        levelPool[3] = rtid('dark_armor3', 'zombieTypes')
                        break;
                    default:
                        break;
                }
                levelPool.push(rtid(select.value, 'ZombieTypes'));
                level.objects[3].objdata.ZombiePool = levelPool;
            }
            //let basicPool = pool.toSpliced(4,pool.length);
            div1.appendChild(select);
            div1.appendChild(table);
        }


        function choice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function sample(arr, k) {
            let result = [];
            for (let i = 0; i < k; i++) {
                let randIndex = Math.floor(Math.random() * arr.length);
                result.push(arr[randIndex]);
                arr.splice(randIndex, 1);
            }
            return result;
        }

        function randint(min, max) {
            if (max < min) {
                [min, max] = [max, min]; // Swap min and max if max is less than min
            }
            // If min and max are equal, return that value
            if (min === max) {
                return min;
            }
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function coinFlip() {
            return Math.random() >= 0.5;
        }

        var level = new Object();
        var objects = new Array();
        var objdata = new Object();
        var waveManager = new Object();
        let escalation = new Object();

        // Define weights for each jam event
        const jamWeights = {
            'jam_rap': 2,
            'jam_punk': 3,
            'jam_metal': 1,
            'jam_ballad': 1,
            'jam_8bit': 4,
            'jam_pop': 3
        };

        // Function to pick a weighted random jam event
        function weightedRandom(jamWeights) {
            const events = Object.keys(jamWeights);
            const weights = Object.values(jamWeights);
            
            // Calculate total weight
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            
            // Generate a random number between 0 and totalWeight
            const random = Math.random() * totalWeight;
            
            // Determine which event is selected
            let cumulativeWeight = 0;
            for (let i = 0; i < events.length; i++) {
                cumulativeWeight += weights[i];
                if (random < cumulativeWeight) {
                    return events[i];  // Return the selected event
                }
            }
        }

        // Function to add jam objects to the core structure
        function addJamObjects() {
            // Jam event types to insert into the core structure
            const jamTypes = Object.keys(jamWeights); // Get jam types from weights

            // Core structure that remains the same
            const baseStructure = { 
                "aliases": [""], 
                "objclass": "SpawnZombiesJitteredWaveActionProps", 
                "objdata": { "NotificationEvents": [""] }
            };

            // Loop through each jam type and create an object with the correct aliases and NotificationEvents
            for (let jamType of jamTypes) {
                let jamEvent = JSON.parse(JSON.stringify(baseStructure));  // Create a copy of the base structure
                jamEvent.aliases[0] = jamType;  // Set the alias
                jamEvent.objdata.NotificationEvents[0] = jamType;  // Set the NotificationEvent

                // Append the jam event
                objects.push(jamEvent);
            }
        }

        // Call the function to add jam objects if the stage is 'Eighties'
        if (stage === 'Eighties') {
            addJamObjects();
        }

        let nonAmbush = ['West', 'Eighties'];
        function waveArray() {
            let emptyWave = [];
            let waveOfEmptyWaves = [];
            for (let i = 1; i < total + 1; i++) {
                if (nonAmbush.includes(stage)) {
                    // Add jams for Eighties stage
                    if (stage === 'Eighties') {
                        let jamEvent = null;
                        if (i % interval == 0 || (i % (interval / 2) == 0 || Math.random()<0.1)) {
                            // Randomly pick one of the jam events based on weight
                            jamEvent = weightedRandom(jamWeights);
                            waveOfEmptyWaves.push([rtid(jamEvent, '.')]);
                        } else {
                            waveOfEmptyWaves.push(emptyWave);
                        }
                    } else {
                        waveOfEmptyWaves.push(emptyWave);
                    }
                    continue;
                }

                // Existing logic for handling ambushes
                if (i % interval === 0) {
                    waveOfEmptyWaves.push([rtid(`wave${i}ambush`, '.')]);
                    ambush(i);
                    if (['Dark', 'Iceage'].includes(stage)) {
                        waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.'));
                    }
                } else if (randint(1, 3) === 3) {
                    waveOfEmptyWaves.push([rtid(`wave${i}ambush`, '.')]);
                    ambush(i);
                    if (['Dark', 'Iceage', 'Beach'].includes(stage)) {
                        waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.'));
                    }
                } else {
                    waveOfEmptyWaves.push(emptyWave);
                }
            }
            return waveOfEmptyWaves;
        }




        function dinoStage() {
            let k;
            // Extend switch to handle cases beyond 4 flags
            switch (flags) {
                case 1: k = randint(1, 2); break;
                case 2: k = randint(2, 3); break;
                case 3: k = randint(3, 5); break;
                case 4: k = 5; break;
                default: k = 5; break; // For any flags greater than 4, set k to the max 5 dinos
            }

            // Select dinos from the pool
            let dinos = sample(["raptor", "ptero", "stego", "tyranno", "ankylo"], k);

            // Create DinoWaveActionProps for each row (5 rows) and for the selected dinos
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < dinos.length; j++) {
                    append0({ "DinoRow": i, "DinoType": dinos[j] }, 'DinoWaveActionProps', `${dinos[j]}${i}`);
                }
            }

            // Initialize the waves
            var waveOfEmptyWaves = [];
            for (let i = 1; i <= total; i++) {
                var emptyWave = [];

                // Dino ambush logic for every interval-th wave and random waves
                if (i % interval === 0 || randint(1, 3) === 3) {
                    for (let j = 0; j < getViolence(i); j++) {
                        emptyWave.push(`${rtid(choice(dinos) + randint(0, 4), '.')}`);
                    }
                }

                // Add the empty wave to the wave list
                waveOfEmptyWaves.push(emptyWave);
            }

            return waveOfEmptyWaves;
        }




        function initialZombiePlacement(start, end, pool, num = randint(1, 10)) {
            let initialZombies = [];
            let cubabalezombies = ["iceage","iceage_armor1","iceage_armor2","iceage_armor4","iceage_armor3","iceage_dodo","iceage_imp","dino_eggshell","eighties_glitter","eighties_boombox"];
            pool = cubabalezombies;
            let occupied = new Set();  // Track occupied positions to avoid overlaps

            while (initialZombies.length < num) {
                let i = randint(0, 4);  // Row (Y-coordinate)
                let j = randint(start, end);  // Column (X-coordinate)
                let pos = { "GridX": j, "GridY": i };
                let posStr = JSON.stringify(pos);

                // Check if the position is already occupied
                if (!occupied.has(posStr)) {
                    occupied.add(posStr);

                    // If stage is 'Iceage', place frozen zombies
                    if (stage === 'Iceage') {
                        initialZombies.push({ ...pos, "TypeName": choice(pool), "Condition": "icecubed" });  // Always frozen
                    } 
                    if (stage === 'Modern') {
                        initialZombies.push({ ...pos, "TypeName": choice(pool), "Condition": "icecubed" });  // Always frozen
                    } 
                    else{
                        break;
                    }
                    // You can add future stages like 'Feastivus' or 'Modern' here later
                }
            }

            // Return the generated list of initial zombie placements
            let objdata = new Object();
            objdata.InitialZombiePlacements = initialZombies;
            append(objdata, "InitialZombieProperties", "IZY");
        }
        const easyPortalTypes = [
            "eighties", "eighties_modern41", "dino",
            "dino_modern41", "lostcity", "iceage", "iceage_hollows", "iceage_hollows_2",
            "beach", "dark", "dark_modern41", "future", "future_2", "future_3",
            "west", "west_modern41", "pirate", "pirate_modern41", "egypt",
            "egypt_2"
        ];

        const normalPortalTypes = [
            "holiday", "holiday_1", "holiday_2", "holiday_3", "holidays", "holidays_3",
            "steam_1", "steam_2","dangerroom_dino_2","egypt","beach"
        ];

        const hardPortalTypes = [
            "modern", "modern_1_modern41", "modern_2_modern41", "modern_3_modern41",
            "modern_4_modern41", "holiday_4",
            "holiday_5", "holiday_6", "holiday_7", "holiday_8", "holiday_9",
            "holiday_10", "holiday_11", "holiday_12",
            "dangerroom_holiday_1", "dangerroom_egypt", "dangerroom_egypt_new",
            "dangerroom_egypt_2", "dangerroom_pirate", "dangerroom_pirate_new",
            "dangerroom_pirate_2", "dangerroom_west", "dangerroom_west_new",
            "dangerroom_west_2", "dangerroom_future", "dangerroom_future_new",
            "dangerroom_future_2", "dangerroom_dark", "dangerroom_dark_new",
            "dangerroom_dark_2", "dangerroom_beach", "dangerroom_beach_new",
            "dangerroom_beach_2", "dangerroom_iceage", "dangerroom_iceage_new",
            "dangerroom_iceage_2", "dangerroom_lostcity", "dangerroom_lostcity_new",
            "dangerroom_lostcity_2", "dangerroom_eighties", "dangerroom_eighties_new",
            "dangerroom_eighties_2", "dangerroom_dino", "dangerroom_dino_new",
            
        ];

        const veteranPortalTypes = [
            "veteran_egypt", "veteran_pirate", "veteran_west", "veteran_eighties",
            "veteran_dino", "veteran_lostcity", "veteran_iceage", "veteran_beach",
            "veteran_dark", "veteran_future", "modern_rally", "eighties_8bit"
        ];
        function portalSpawn(wav) {
            let row = randint(0, 8);
            let portals = [];
            let column = [];
            let maxportal = randint(1,difficulty);
            let portalNum = 1;  // Default to 1 portal if not specified
            let violence = getViolence(wav);

            switch (violence) {
                case 0:
                    portals = [choice(easyPortalTypes)];
                    break;
                case 1:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(1, 2));
                    break;
                case 2:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(2, 3));
                    break;
                case 3:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(3, 4));
                    portalNum = randint(0, 4);
                    break;
                case 4:
                    portals = sample(easyPortalTypes.concat(hardPortalTypes), randint(4, 6));
                    portalNum = randint(3, 6);
                    break;
                default:
                    portals = sample(hardPortalTypes.concat(veteranPortalTypes), randint(7, 12));
                    portalNum = randint(0,6);
                    break;
            }
            portalNum=Math.min(portalNum,maxportal);
            return {portals,  portalNum};
        }

        // Function to create and configure the modern stage
        function modernStage() {
            const waveConfigs = Array(total).fill([]);  // Initialize waves as empty arrays
            let row=8;
            let column = 2;
            for (let waveIndex = 1; waveIndex < total; waveIndex++) {  // Start from wave 1
                let violence = getViolence(waveIndex) / 7;  // Scale violence
                const {portals, portalNum } = portalSpawn(violence);

                // Determine the number of portals to add based on waveIndex and difficulty
                let numPortalsToAdd = Math.min(10,portalNum); // Scale from 3 portals upwards as waveIndex and violence increase

                // Ensure at least 1 portal spawns if the wave is over the interval or difficulty is high enough
                if (waveIndex >= interval || violence >= Math.random()) {
                    const wavePortals = [];

                    // Add portals to this wave
                    for (let i = 0; i < numPortalsToAdd; i++) {
                        row = randint(0,4);
                        column = randint(4,8);
                        const portalId = `PortalSpawn${waveIndex}_${column}${row}`;
                        wavePortals.push(`RTID(${portalId}@.)`);

                        // Append new portal configuration for spawning
                        append0({
                            "PortalColumn": column,
                            "PortalRow": row,
                            "PortalType": portals[randint(0,portals.length-1)],
                        }, 'SpawnModernPortalsWaveActionProps', portalId);
                    }

                    // Add the portals generated to the waveConfigs
                    waveConfigs[waveIndex] = wavePortals;

                    // Chance to append additional portals if the difficulty and wave index are high enough
                    if (waveIndex > Math.floor(total / 2) && violence > Math.random()) {
                        let extraPortals = Math.floor(Math.random() * (10 - numPortalsToAdd));  // Chance to add more portals
                        for (let i = 0; i < numPortalsToAdd; i++) {
                            row = randint(0,4);
                            column = randint(3,8);
                            const portalId = `PortalSpawn${waveIndex}_${column}${row}`;
                            wavePortals.push(`RTID(${portalId}@.)`);

                            // Append new portal configuration for spawning
                            append0({
                                "PortalColumn": column,
                                "PortalRow": row,
                                "PortalType": portals[randint(0,portals.length-1)],
                            }, 'SpawnModernPortalsWaveActionProps', portalId);
                        }
                    }
                }
            }
            updateWaveManager(waveConfigs);
        }





        function updateWaveManager(waveConfigs) {
            append0({
                "Waves": waveConfigs
            }, 'WaveManagerProperties', 'WaveManager');
        }





        function sample(arr, k) {
            let result = [];
            for (let i = 0; i < k; i++) {
                let randIndex = Math.floor(Math.random() * arr.length);
                result.push(arr[randIndex]);
                arr.splice(randIndex, 1);
            }
            return result;
        }

        function getWaveManagerConfig() {
            return { "objdata": { "Waves": [] } };
        }

        function setWaveManagerConfig(config) {
            console.log("WaveManager configuration updated:", config);
        }


        function getViolence(wave) {
            if (wave < 3) {
                return 1;
            } else if (wave < 6) {
                return randint(1, 2);
            } else if (wave < 10) {
                return randint(2, 3);
            } else if (wave < 16) {
                return randint(4, 6);
            }
            else return randint(1, 8);
        }

        let cappedStartingPoints = randint(150,difficulty*50);
        let cappedPointIncrement = randint(10,70*difficulty);



        let plantfoodToSpawnCount =randint(3,difficulty);


        
        escalation.FlagCount = flags;
        escalation.WavesPerFlag = interval;
        escalation.PlantfoodToSpawnCount = plantfoodToSpawnCount;  
        escalation.StartingPoints = cappedStartingPoints;
        escalation.PointIncrementPerWave = cappedPointIncrement;
        escalation.WaveManagerProps = "RTID(WaveManager@CurrentLevel)";
        escalation.ZombiePool = pool;





        var modules = [];

        function append(objdata, objclass, alias) {
            let obj = new Object();
            if (!(alias === undefined)) {
                obj.aliases = [alias];
                modules.push(`RTID(${alias}@.)`);
            }
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        function append0(objdata, objclass, alias) {
            let obj = new Object();
            obj.aliases = [alias];
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        modules.push("RTID(StandardIntro@LevelModules)");
        modules.push("RTID(ZombiesDeadWinCon@LevelModules)");
        modules.push("RTID(DefaultZombieWinCondition@LevelModules)");
        let mowers = false;
        if (coinFlip()) {
            if (stage ==`Harvest` || stage ==`Summer`){
                modules.push(`RTID(HolidayMowers@LevelModules)`) ;
            }
            else {
                modules.push(`RTID(${stage}Mowers@LevelModules)`) ;
            }
            
            mowers = true;
             
        }

        if (stage !== 'Dark' && stage !== 'Summer') {
            
            modules.push("RTID(DefaultSunDropper@LevelModules)") ;
        };

        objdata.StartingSun = randint(1, 4) * 25;
        objdata.Description = "Inszanity on a next level";
        objdata.Loot = "RTID(DefaultLoot@LevelModules)";
        objdata.Modules = modules;
        objdata.Name = choice([
        "Inzanity awaits -", 
        "Supreme Inzanity -", 
        "Brace for the horde -", 
        "Plankton tip: Use Winter Melon to melt the horde -", 
        "This is far from endless -", 
        "The madness begins -", 
        "Meltdown imminent -", 
        "Zombies rising -", 
        "Survival at its peak -", 
        "There is a zombie on your lawn ! -", 
        "Conquer the horde -", 
        "Winter Melon saves the day -", 
        "Doomed from the start -", 
        "Zombot's sanity -", 
        "The last stand -",
        "balls -",
        "no idea for level name -"
    ]) + stage + " " + difficultyText + " Difficulty";

        if (difficulty > 3) {
            if (stage === "Iceage") {
                objdata.StageModule = `RTID(${stage}VeteranStage@LevelModules)`;
                objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`, `MiniGame_MiniBoss`])
            }
            if (stage === 'Modern' ) {
                objdata.StageModule = `RTID(${stage}NightStage@LevelModules)`;
                objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`]);
            }
            if (stage === 'Harvest' ){
                objdata.MusicType = choice([`MiniGame_MiniBoss`])
                objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
            }
            else {
                objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
                if (coinFlip()) {
                    objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`]);
                }
                
            }
        if (stage === 'Modern' ) {
            objdata.StageModule = `RTID(${stage}AllJamsStage@LevelModules)`;
        }
        } else {
            objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
            modules.push("RTID(DefaultSunDropper@LevelModules)") ;
        }
        if (stage === 'Modern') {
            objdata.ResourceGroupNames = [
                "DelayLoad_Background_Beach",
                "DelayLoad_Background_Beach_Compressed",
                "Tombstone_Dark_Special",
                "Tombstone_Dark_Effects"
            ]
        }



        waveManager.FlagWaveInterval = interval;
        waveManager.WaveCount = total;
        waveManager.SuppressFlagZombie = false;

        append(objdata, 'LevelDefinition');
        append({ "SelectionMethod": "chooser" }, "SeedBankProperties", "SeedBank");
        append({}, "WaveManagerModuleProperties", "NewWaves");
        append(escalation, "LevelEscalationModuleProperties", "Escalation");

        if (stage == 'Dino') { waveManager.Waves = dinoStage() }
        else if (stage == 'Modern') {
             waveManager.Waves = modernStage();
        }
        else waveManager.Waves = waveArray();


        append(waveManager, "WaveManagerProperties", "WaveManager");

        level.objects = objects;
        level.version = 1;
        let occupied = new Set();

        switch (stage) {
            case 'Egypt':
                chessboard(2, 8, ['gravestone_egypt']);
                break;
            case 'Modern':
                if (coinFlip()){
                    initialZombiePlacement(3, 7, pool, randint(2, 3));
                }
                chessboard(1, 8, ['goldtile','tar','goldtile','goldtile','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','surfboard', 'gravestoneSunOnDestruction','bufftile_attack','bufftile_speed','bufftile_shield']);
                break;
            case 'Pirate':
                append({ "PlankRows": sample([0, 1, 2, 3, 4], randint(1, 5)).sort() }, "PiratePlankProperties", "PiratePlanks");
                pool.push(...sample(flyingUnits, randint(2, 4)));
                break;
            case 'West':
                railCarts();
                break;
            case 'Harvest':
                railCarts();
                break;
            case 'Summer':
                chessboard(0, 3, ["fireworks", 'speaker','presentSunOnDestruction','presentPlantfoodOnDestruction','presentPlantOnDestruction','presentPlantOnDestruction_valentines']);
                break;
            case 'Future':
                let diceRoll = randint(1, 3); // Random number of power tiles
                let latinPower = ['alpha', 'beta', 'gamma', 'delta'];
                let strPower = 'powertile_';

                // Pick random latin letters for power tiles
                latinPower = sample(latinPower, diceRoll);

                // Buff tile types
                let latinBuff = ['attack', 'speed', 'shield'];
                let strBuff = 'bufftile_';
                let diceRollBuff = randint(1, 2);
                latinBuff = sample(latinBuff, diceRollBuff);

                // Combined grid placements for both power and buff tiles
                var InitialGridItemPlacements = [];

                // Iterate and place both power tiles and buff tiles
                for (let i = 0; i < latinPower.length; i++) {
                    // Power tile placement
                    InitialGridItemPlacements.push(...powertileBoard(0, 4, strPower + latinPower[i], randint(2, 5)));

                    // Buff tile placement at the same position
                    if (i < latinBuff.length) {
                        InitialGridItemPlacements.push(...bufftileBoard(0, 4, strBuff + latinBuff[i], randint(2, 5)));
                    }
                }

                // Single object to store both power and buff tile placements
                var obj = new Object();
                obj.InitialGridItemPlacements = InitialGridItemPlacements;

                // Append to the 'GI' module just once
                append(obj, 'InitialGridItemProperties', 'GI');
                break;

            case 'Dark':
                chessboard(2, 8, ['gravestone_dark', 'gravestone_dark', 'gravestoneSunOnDestruction']);
                break;
            case 'Beach':
                let columns = [9, 8, 7, 6, 5, 4];
                let index = randint(0, 5);

                // Add Initial Tide setup
                append({
                    "StartingWaveLocation": columns[index],  // Random column for the tide to start
                    "ShowTideMarker": true                   // Show the tide marker
                }, "TideProperties", "InitialTide");

                // Add beach grid items (e.g., surfboard and lilypad) for visual and gameplay elements
                chessboard(3, 6, ['surfboard', 'lilypad'], randint(2, 4));

                break;
            case 'Iceage':
                chessboard(3, 7, ['gravestone_iceage'], randint(4, 5));
                initialZombiePlacement(3, 7, pool, randint(4, 6));
                break;
            case 'Dino':
                chessboard(1, 8, ['crater', 'tar', 'rock'], randint(3, 7));
                break;
            case 'Eighties':
                chessboard(2, 8, ['eightiesarcadecabinet', 'bufftile_shield','bufftile_speed', 'speaker', 'speaker', 'speaker'], randint(4, 7));
                break;
            case 'LostCity':
                chessboard(0, 5, ['goldtile', 'goldtile', 'goldtile', 'gravestone_lostcity', 'boulder_trap_falling_forward', 'flame_spreader_trap'], randint(1, 7));
            default:
                break;
        }

        for (let i = 0; i < pool.length; i++) {
            pool[i] = `RTID(${pool[i]}@ZombieTypes)`;
        }

        window.onload = function () {
            let filename = localStorage.getItem('filename');
            let levelnum = localStorage.getItem('levelnum');
            let selectedStage = localStorage.getItem('stage');

            let stageSelect = document.getElementById('stage');
            let select = document.getElementById('filename');
            if (filename !== null) {
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === filename) {
                        select.selectedIndex = i;
                        break;
                    }
                }
            }
            if (selectedStage !== null) {
                for (let i = 0; i < stageSelect.options.length; i++) {
                    if (stageSelect.options[i].value === selectedStage) {
                        stageSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            let num = document.getElementById('levelnum');
            if (levelnum !== null) {
                num.value = levelnum;
            }
        }

        // Save the selected values and reload the page

        function reload() {
            let num = document.getElementById('levelnum');
            let filename = document.getElementById('filename');
            let stageElement = document.getElementById('stage');
            localStorage.setItem('levelnum', num.value);
            let selectedFilename = filename.options[filename.selectedIndex].value;
            let selectedStage = stageElement.options[stageElement.selectedIndex].value;
            localStorage.setItem('filename', selectedFilename);
            localStorage.setItem('stage', selectedStage);
            location.reload();
        }




        // Debug function to find index by alias
        function findIndexWithAlias(objects, targetAlias) {
            const index = objects.findIndex(obj =>
                obj.aliases && Array.isArray(obj.aliases) && obj.aliases.includes(targetAlias)
            );
            return index;
        }

        // Debug function to find index by class
        function findIndexWithClass(objects, targetClass) {
            const index = objects.findIndex(obj => obj.objclass === targetClass);
            return index;
        }

        function chessboard(start, end, typeName, num = randint(0, 20)) {
            let grids = [];
            let occupied = new Set();
            let columnSliders = {};  // Tracks the sliders in each column for backward connection checking

            // Helper function to check if there is a valid path leading back to a previous slider
            function isValidSliderPlacement(gridX, gridY) {
                // Check all columns to the left of the current position (GridX = gridX, GridY = gridY)
                for (let j = gridX - 1; j >= start; j--) {
                    // Check if there is a slider in the same row leading backward
                    let leftSlider = columnSliders[j] ? columnSliders[j].find(slider => slider.GridY === gridY) : null;
                    if (leftSlider) {
                        return true;  // Valid path exists, so slider can be placed
                    }
                }
                return false;  // No valid path, cannot place a second slider here
            }

            // Place the grid items
            while (grids.length < num) {
                let i = randint(0, 4);  // Row (Y-coordinate)
                let j = randint(start, end);  // Column (X-coordinate)
                let pos = { "GridX": j, "GridY": i };
                let posStr = JSON.stringify(pos);
                let validSliderPlacement = true;

                if (!occupied.has(posStr)) {
                    // If it's Modern or Iceage stage, allow sliders and other grid items
                    if (stage === 'Modern' || stage === 'Iceage') {
                        let randomType = Math.random();
                        let shouldPlaceSlider = randomType < 0.3;  // 30% chance to place a slider, rest are normal items

                        if (shouldPlaceSlider) {
                            let sliderType;
                            
                            // Determine slider direction (up or down)
                            if (randomType < 0.15) {
                                sliderType = (stage === 'Modern') ? 'slider_down_modern' : 'slider_down';  // Slider Down
                                if (i === 4) validSliderPlacement = false;  // Cannot place down sliders in row 4 (Y-axis restriction)
                            } else {
                                sliderType = (stage === 'Modern') ? 'slider_up_modern' : 'slider_up';  // Slider Up
                                if (i === 0) validSliderPlacement = false;  // Cannot place up sliders in row 0 (Y-axis restriction)
                            }

                            // Check if there is a valid backward path before placing the second slider
                            if (columnSliders[j] && columnSliders[j].length >= 1) {
                                if (!isValidSliderPlacement(j, i)) {
                                    validSliderPlacement = false;  // Disallow if no backward path leads to this slider
                                }
                            }

                            // If placement is valid, add the slider to the grid and update columnSliders
                            if (validSliderPlacement) {
                                grids.push({ ...pos, "TypeName": sliderType });
                                if (!columnSliders[j]) columnSliders[j] = [];
                                columnSliders[j].push(pos);  // Track slider in column
                                occupied.add(posStr);
                            }

                        } else {
                            // Otherwise, place a regular grid item from typeName array
                            grids.push({ ...pos, "TypeName": choice(typeName) });
                            occupied.add(posStr);
                        }

                    } else {
                        // For other stages, just place normal grid items from typeName array
                        grids.push({ ...pos, "TypeName": choice(typeName) });
                        occupied.add(posStr);
                    }
                }
            }

            // Finalize grid placements
            let objdata = new Object();
            objdata.InitialGridItemPlacements = grids;
            append(objdata, "InitialGridItemProperties", "GI");
        }




        function powertileBoard(start, end, typeName, num) {
            let grids = [];
            while (grids.length < num) {
                let i = randint(0, 4);  // Random Y between 0 and 4 (rows)
                let j = randint(start, Math.min(end, 7));  // X capped at 7
                if (grids.length < num) {
                    let pos = { "GridX": j, "GridY": i };
                    grids.push({ ...pos, "TypeName": typeName });  // Allowing overlap
                }
            }
            return grids;
        }

        // Buff tile spawns on the far edge, always at x = 8
        function bufftileBoard(start, end, typeName, num) {
            let grids = [];
            while (grids.length < num) {
                let i = randint(0, 3);  // Random Y between 0 and 3 (rows)
                let j = 8;  // Always spawn at x = 8
                if (grids.length < num) {
                    let pos = { "GridX": j, "GridY": i };
                    grids.push({ ...pos, "TypeName": typeName });  // Allowing overlap
                }
            }
            return grids;
        }

        function railCarts() {
            let objdata = new Object();

            // Available minecart types
            let railcartTypes = [
                "railcart_tutorial", // Modern
                "railcart_cowboy",   // Cowboy
                "railcart_egypt",    // Egypt
                "railcart_pirate",   // Pirate
                "railcart_future",   // Future
                "railcart_steam"     // Steam Age
            ];

            // Randomly select a railcart type for this wave
            objdata.RailcartType = sample(railcartTypes, 1)[0];

            let rails = [];
            let carts = [];
            let cartCount = 0;  // Track the total number of railcarts

            for (let i = 0; i < 8; i++) {
                if (cartCount >= 4) break;  // Stop if the max of 4 railcarts is reached

                var diceRoll = randint(1, 6);
                var rows = sample([0, 1, 2, 3, 4], 2);
                var end = Math.max(...rows);
                var start = Math.min(...rows);

                switch (diceRoll) {
                    case 1:
                    case 6:
                        continue;
                    case 2:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                            carts.push({ "Column": i, "Row": randint(0, 4) });
                            cartCount++;
                        }
                        break;
                    case 3:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": end, "RowStart": start, "Column": i });
                            carts.push({ "Column": i, "Row": randint(start, end) });
                            cartCount++;
                        }
                        break;
                    case 4:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 3, "Column": i });
                            rails.push({ "RowEnd": 1, "RowStart": 0, "Column": i });

                            if (cartCount < 4) {
                                carts.push({ "Column": i, "Row": randint(3, 4) });
                                cartCount++;
                            }
                            if (cartCount < 4) {
                                carts.push({ "Column": i, "Row": randint(0, 1) });
                                cartCount++;
                            }
                        }
                        break;
                    case 5:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                            carts.push({ "Column": i, "Row": start });
                            cartCount++;
                        }
                        if (cartCount < 4) {
                            carts.push({ "Column": i, "Row": end });
                            cartCount++;
                        }
                        break;
                    default:
                        break;
                }
            }

            objdata.Rails = rails;
            objdata.Railcarts = carts;
            append(objdata, "RailcartProperties", "CowboyRails");
        }




        /*
        {"aliases":["Sandstorm1_C1"],
        "objclass": "StormZombieSpawnerProps",
        "objdata": {
        objdata.AdditionalPlantfood = "0",
        objdata.Type = "sandstorm",
        objdata.ColumnStart = 1,
        objdata.ColumnEnd = 1,
        objdata.TimeBetweenGroups = 0.5,
        objdata.GroupSize = 1,
            "Zombies": [
                {"Type": "RTID(tutorial@ZombieTypes)"},
                {"Type": "RTID(tutorial@ZombieTypes)"}
            ]
        }},
        */
        function addObjectives() {
            const survivalTimeObjective = Math.min(10,randint(180/2,(180*difficulty)/2)); // Time in seconds for survival objective

            // Only add objectives if the level has no mowers
            if (!mowers) {
                objects.push({
                    "objclass": "StarChallengeBeatTheLevelProps",
                    "objdata": {
                        "Description": "Survive without any lawn mowers",
                        "DescriptiveName": "Custom Objective"
                    }
                });
            }

            // Check difficulty and add survival timer with 30% chance
            if (difficulty > 3 && Math.random() < 0.3) {
                objects.push({
                    "objclass": "StarChallengeLevelTimerProperties",
                    "objdata": {
                        "TimeLimit": survivalTimeObjective
                    }
                });
            }
        }
        function stormAmbush(wave, type) {
            let violence= getViolence(wave);
            let pool = [];
            var basic, imp, conhead, buckethead, brickhead, garg;
            switch (type) {
                case 'sand':
                    basic = "mummy";
                    imp = "egypt_imp"
                    conehead = "mummy_armor1";
                    buckethead = "mummy_armor2";
                    brickhead = "mummy_armor4";
                    garg = "tomb_raiser";
                    break;
                case 'pirate':
                    imp = "pirate_imp"
                    garg = "pirate_gargantuar";
                    break;
                case 'future':
                    imp = "future_imp"
                    garg = "future_gargantuar";
                    break;
                case 'cowboy':
                    imp = "west_bullrider"
                    garg = "cowboy";
                    break;
                case 'dino':
                    imp = "dino_imp"
                    garg = "dino_gargantuar";
                    break;
                case 'beach':
                    imp = "beach_imp"
                    garg = "beach_gargantuar";
                    break;
                case 'dark':
                    basic = { "Type": "RTID(dark@ZombieTypes)" };
                    conehead = { "Type": "RTID(dark_armor1@ZombieTypes)" };
                    buckethead = { "Type": "RTID(dark_armor2@ZombieTypes)" };
                    brickhead = { "Type": "RTID(dark_armor3@ZombieTypes)" };
                    imp = { "Type": "RTID(dark_imp@ZombieTypes)" };
                    garg = { "Type": "RTID(dark_gargantuar@ZombieTypes)" };
                    break;
                case 'snow':
                    basic = "iceage";
                    conehead = "iceage_armor1";
                    buckethead = "iceage_armor2";
                    brickhead = "iceage_armor3";
                    imp = "iceage_imp";
                    garg = "iceage_dodo";
                    break;
                case 'eighties':
                    imp = "eighties_imp";
                    garg = "eighties_gargantuar";
                    break;
                case 'summer':
                    basic = "summer_basic";
                    conehead = "summer_armor1";
                    buckethead = "summer_armor2";
                    brickhead = "eighties_armor4";
                    imp = "summer_imp"
                    garg = "summer_gargantuar";
                    break;
                default:
                    imp = "zcorp_imp"
                    garg = "zcorp_gargantuar";;
                    break;
            }
            let start = 1;
            let num = 0;
            let end = 0;

            switch (violence) {
                case 0:
                    pool = [basic];
                    start = 6;
                    end = 8;
                    num = 1;
                    break;
                case 1:
                    pool = [basic, imp, conehead];
                    start = 5;
                    end = 7;
                    num = randint(1, difficulty);
                    break;
                case 2:
                    pool = [basic, imp, imp, conehead];
                    start = 4;
                    end = 7;
                    num = randint(2, difficulty + 1);
                    break;
                case 3:
                    pool = [imp, conehead, imp, buckethead, garg];
                    start = 3;
                    end = 6;
                    num = randint(3, difficulty + 2);
                    break;
                case 4:
                    pool = [buckethead, basic, buckethead,imp, brickhead, brickhead, brickhead, garg];
                    start = 2;
                    end = 6;
                    num = randint(4, difficulty + 4);
                    break;
                default:
                    pool = [buckethead, basic, buckethead,imp, brickhead, brickhead, brickhead, garg];
                    start = 2;
                    end = 6;
                    num = randint(4, difficulty + 4);
                    break;
            }
            let objdata = new Object();
            objdata.AdditionalPlantfood = "0",
                objdata.Type = `${type}storm`,
                objdata.ColumnStart = start,
                objdata.ColumnEnd = end,
                objdata.TimeBetweenGroups = 0.5,
                objdata.GroupSize = randint(1,3);
            let temp = [];
            for (let i = 0; i < num; i++) {
                temp.push({ "Type": `RTID(${choice(pool)}@ZombieTypes)` });
            }
            objdata.Zombies = temp;
            if (type == 'dark') {
                return pool;
                
            }
            append0(objdata, "StormZombieSpawnerProps", `wave${wave}ambush`);
        }

        /*
        "GroupSize": 3,
        "SwashbucklerCount": 3,
        "TimeBetweenGroups": 1
        */

        function raidingParty(wave) {
            let violence= getViolence(wave);
            let objdata = new Object();
            let times = [1.5, 1.25, 1.0, 0.75, 0.5, 0.25, 0.1];

            objdata.GroupSize = randint(1, 3);
            switch (violence) {
                case 0:
                    objdata.TimeBetweenGroups = times[0];
                    objdata.SwashbucklerCount = 1;
                    break;
                case 1:
                    objdata.TimeBetweenGroups = times[randint(1, 4)];
                    objdata.SwashbucklerCount = randint(2, difficulty/2);
                    break;
                case 2:
                    objdata.TimeBetweenGroups = times[randint(3, 5)];
                    objdata.SwashbucklerCount = randint(3, difficulty/2 + 2);
                    break;
                case 3:
                    objdata.TimeBetweenGroups = times[randint(5, 6)];
                    objdata.SwashbucklerCount = randint(9, difficulty/2 + 12);
                    break;
                case 4:
                    objdata.TimeBetweenGroups = times[6];
                    objdata.SwashbucklerCount = randint(10, difficulty/2 + 13);
                    break;
            }
            append0(objdata, 'RaidingPartyZombieSpawnerProps', `wave${wave}ambush`);
        }

        function rain(wave) {
            var num = 0;
            var start = 0;
            var end = 0;
            var time = 0;
            let violence= getViolence(wave);
            switch (violence) {
                case 0:
                    time = 1.0;
                    start = 6;
                    end = 8;
                    num = randint(1, 2);
                    break;
                case 1:
                    time = 1.5;
                    start = 5;
                    end = 7;
                    num = randint(2, 4);
                    break;
                case 2:
                    time = 1.5;
                    start = 3;
                    end = 6;
                    num = randint(4, 7);
                    break;
                case 3:
                    time = 1.5;
                    start = 3;
                    end = 6;
                    num = randint(6, 9);
                    break;
                case 4:
                    time = 1.5;
                    start = 2;
                    end = 6;
                    num = randint(8, 14);
                    break;
                default:
                    time = 1.1;
                    start = 2;
                    end = 6;
                    num = randint(8, 20);
            }
            let objclass, name, message;
            switch (stage) {
                case 'Future':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'future_imp'
                    message = choice(['Bot Swarm!', 'Fallen Technologie!'])
                    break;
                case 'Harvest':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'harvest_imp'
                    message = 'Feather Falling!'
                    break;
                case 'LostCity':
                    objclass = 'ParachuteRainZombieSpawnerProps'
                    name = 'lostcity_lostpilot'
                    message = 'Parachute Rain!'
                    break;
                case 'Summer':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'summer_imp'
                    message = 'Hot Dogs!'
                    break;

                default:
                    if (Math.random() < 0.2) {
                        objclass = 'ParachuteRainZombieSpawnerProps'
                        name = 'zcorp_helpdesk'
                        message = 'inzanity support!'
                    }
                    break;
            }
            let objdata = new Object();
            objdata.ColumnStart = start;
            objdata.ColumnEnd = end;
            objdata.SpiderCount = num;
            objdata.TimeBetweenGroups = `${time}`;
            objdata.ZombieFallTime = `${time}`;
            objdata.SpiderZombieName = name;
            objdata.WaveStartMessage = message;
            append0(objdata, objclass, `wave${wave}ambush`);
        }

        function necromancy(wave, violence) {
            let objdata = new Object();
            objdata.AdditionalPlantfood = '0';
            objdata.GridTypes = ["RTID(gravestone_dark@GridItemTypes)"];
            objdata.WaveStartMessage = '[WARNING_GRAVESTONE_SPAWN]';
            objdata.ZombieSpawnWaitTime = '1';
            objdata.Zombies = stormAmbush(wave, 'dark', violence);
            append0(objdata, "SpawnZombiesFromGridItemSpawnerProps", `wave${wave}ambushExtra`);
        }

        // Function to generate grid spawn data
        function graveSpawn(wave, violence) {
            let num = randint(2,5);
            switch (violence) {
                case 0: num = randint(1, 2); break;
                case 1: num = randint(2, 4); break;
                case 2: num = randint(2, 6); break;
                case 3: num = randint(4, 8); break;
                case 4: num = randint(7, 12); break;
                default: num = randint(7, 12); break;
            };
            let sun = 0;
            let regular = 0;
            while (num !== 0) {
                let diceRoll = randint(1, num);
                regular += diceRoll;
                num -= diceRoll;
                diceRoll = randint(1, num);
                sun += diceRoll;
                num -= diceRoll;
            }
            let objdata = new Object();
            objdata.GravestonePool = [
                { "Count": Math.abs(regular), "Type": "RTID(gravestone_dark@GridItemTypes)" },
                { "Count": Math.abs(sun), "Type": "RTID(gravestoneSunOnDestruction@GridItemTypes)" }
            ]
            objdata.SpawnEffectAnimID = 'POPANIM_EFFECTS_TOMBSTONE_DARK_SPAWN_EFFECT';
            objdata.SpawnPositionsPool = [{ "mX": 1, "mY": 0 }, { "mX": 1, "mY": 1 }, { "mX": 1, "mY": 2 }, { "mX": 1, "mY": 3 }, { "mX": 1, "mY": 4 }, { "mX": 2, "mY": 0 }, { "mX": 2, "mY": 1 }, { "mX": 2, "mY": 2 }, { "mX": 2, "mY": 3 }, { "mX": 2, "mY": 4 }, { "mX": 3, "mY": 0 }, { "mX": 3, "mY": 1 }, { "mX": 3, "mY": 2 }, { "mX": 3, "mY": 3 }, { "mX": 3, "mY": 4 }, { "mX": 4, "mY": 0 }, { "mX": 4, "mY": 1 }, { "mX": 4, "mY": 2 }, { "mX": 4, "mY": 3 }, { "mX": 4, "mY": 4 }, { "mX": 5, "mY": 0 }, { "mX": 5, "mY": 1 }, { "mX": 5, "mY": 2 }, { "mX": 5, "mY": 3 }, { "mX": 5, "mY": 4 }, { "mX": 6, "mY": 0 }, { "mX": 6, "mY": 1 }, { "mX": 6, "mY": 2 }, { "mX": 6, "mY": 3 }, { "mX": 6, "mY": 4 }, { "mX": 7, "mY": 0 }, { "mX": 7, "mY": 1 }, { "mX": 7, "mY": 2 }, { "mX": 7, "mY": 3 }, { "mX": 7, "mY": 4 }, { "mX": 8, "mY": 0 }, { "mX": 8, "mY": 1 }, { "mX": 8, "mY": 2 }, { "mX": 8, "mY": 3 }, { "mX": 8, "mY": 4 }];
            objdata.SpawnSoundID = 'Play_Zomb_Egypt_TombRaiser_Grave_Rise';
            append0(objdata, "SpawnGravestonesWaveActionProps", `wave${wave}ambush`);
        }

    


    




        function ambush(wave) {
            if (stage === 'West') {
                return;
            }

            switch (stage) {
                case 'Modern':
                    portalSpawn(wave);
                    break;
                case 'Iceage':
                    ambushRoulette(wave);
                    break;
                case 'Egypt':
                    stormAmbush(wave, 'sand');
                    break;
                case 'Pirate':
                    raidingParty(wave);
                    break;
                case `Summer`:
                case `Harvest`:
                case 'Future':
                case 'LostCity':
                    rain(wave);
                    break;
                case 'Dark':
                    ambushRoulette(wave);
                    break;
                case 'Beach':
                    let columns = [9, 8, 7, 6, 5, 4, 3, 2, 1];
                    let index = randint(0, columns.length - 1);

                    // Get the violence level based on the wave index
                    let violence = getViolence(wave); 

                    // Random zombie selection based on violence level
                    let zombies = ['beach_armor1', 'beach_fem']; // Replace with actual zombie types
                    let zombieCount = 1; // Randomize number of zombies based on violence
                    let selectedZombies = choice(zombies); // Select a random zombie type

                    // Apply tidal changes for specific waves
                    append0({
                        "TidalChange": {
                            "ChangeAmount": columns[index],  // Change tide based on random column
                            "ChangeType": "absolute"         // Absolute change type
                        },
                    }, 'TidalChangeWaveActionProps', `wave${wave}ambush`);

                    // Spawn zombies with low tide event
                    append0({
                        "objclass": "BeachStageEventZombieSpawnerProps",
                        "objdata": {
                            "ColumnStart": 5,
                            "ColumnEnd": 7,
                            "ZombieCount": zombieCount,      // Number of zombies based on violence level
                            "GroupSize": 1,
                            "TimeBetweenGroups": "0.05",
                            "ZombieName": `${selectedZombies}`, // Selected zombie type
                            "WaveStartMessage": "Low Tide!"
                        }
                    }, 'BeachStageEventZombieSpawnerProps', `wave${wave}ambushExtra`);

                    break;


                default:
                    break;
            }
        }


        function winds(wave, violence) {
            let winds = [{ "Direction": "left", "Row": "0" }, { "Direction": "left", "Row": "1" }, { "Direction": "left", "Row": "2" }, { "Direction": "left", "Row": "3" }, { "Direction": "left", "Row": "4" }, { "Direction": "right", "Row": "0" }, { "Direction": "right", "Row": "1" }, { "Direction": "right", "Row": "2" }, { "Direction": "right", "Row": "3" }, { "Direction": "right", "Row": "4" }];
            let objdata = new Object();
            let temp = [];
            switch (violence) {
                case 0: temp = sample(winds, randint(1, 2)); break;
                case 1: temp = sample(winds, randint(1, 4)); break;
                case 2: temp = sample(winds, randint(2, 6)); break;
                case 3: temp = sample(winds, randint(3, 8)); break;
                case 4: temp = sample(winds, randint(4, 10)); break;
            }
            objdata.Winds = temp;
            append0(objdata, 'FrostWindWaveActionProps', `wave${wave}ambushExtra`)
        }

        function ambushRoulette(wave) {
            let diceRoll;
            let violence= getViolence(wave);
            if (violence > 1) { diceRoll = randint(1, 3); }
            else diceRoll = randint(1, 2);
            switch (diceRoll) {
                case 1:
                    let violence1 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        necromancy(wave, violence1);
                    } else {
                        stormAmbush(wave, 'snow', violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambushExtra`);
                    break;

                case 2:
                    let violence2 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        necromancy(wave, violence2);
                    } else {
                        winds(wave, violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambush`);
                    break;

                case 3:
                    let violence3 = Math.max(0, violence - 5 + difficulty);
                    if (stage == 'Dark') {
                        graveSpawn(wave, violence3);
                        necromancy(wave, Math.max(0, violence - 5 + difficulty));
                    } else {
                        stormAmbush(wave, 'snow', Math.max(0, violence - 5 + difficulty));
                        winds(wave, violence);
                    }
                    break;

                default:
                    break;
            }

        }

    </script>
</body>

</html>