<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvZ2 level randomizer</title>
    <link rel="stylesheet" href="style.css">
    <script src="randombg.js"></script>
    <style>
        .level-preview {
            border: 2px solid #333;
            padding: 10px;
            width: 300px;
            margin: 10px;
        }
        .level-preview .variable {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        .variable-name {
            font-weight: bold;
        }
        .variable-value {
            text-align: right;
        }
        #zombieSelectionModal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #zombieSelectionContent {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-height: 60%;
            overflow-y: auto;
        }
        .zombie-checkbox {
            margin: 5px;
        }
        .zombie-category {
            margin-bottom: 15px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        .zombie-category h3 {
            margin-top: 0;
        }
    </style>
</head>

<body>
    <div id="snackbar">Some text some message..</div>
    <div id="div1" class="filename-container">
        <label>Options:</label>
            <select onchange="setMod(this.value)" name="mod" id="modOption">
                <option value="vnl" disabled>VNL (Coming Soon)</option> <!-- Disabled VNL -->
                <option value="rfl" selected>RFL</option> <!-- Default selected -->
            </select>


        <label>Filename: </label><select id="filename"></select>
        <input style="width: 40px;" value="1" type="number" min="1" max="40" id="levelnum">
        .json<br>
        <label>Stage: </label>
        <select id="stage"></select>
        <br>
        <h2>Select Difficulty</h2>
        <div class="select-container">
            <label for="difficulty">Difficulty Level:</label>
            <select id="difficulty" name="difficulty" onchange="updateDifficultyText(this)">
                <option hidden defaultSelected>-</option>
                <option value="1">Easy</option>
                <option value="2">Normal</option>
                <option value="3">Inzane</option>
                <option value="4">CRAAAZY!</option>
                <option value="5">Johan</option>
            </select>
        </div><br>
    </div>
    
    <div class="filename-container">
        <h2>PvZ2 Level Preview</h2>
    
        <div id="levelPreview" class="inner-container">
            <!-- This is where the preview will appear -->
        </div>
        <button onclick="generatePreview()">Preview Variables</button><br>
        <button id="Copy" onclick="copyCode()">Copy</button>
        <p> or </p>
        <button id="buttonA" onclick="startDownload()">Download</button>
        <button id="selectZombiesBtn" onclick="openZombieSelection()">Select Zombies Manually</button>
        <div id="discordReminder" style="text-align: center; margin-top: 20px;">
            <p>Don't forget to join our <a href="https://discord.gg/PkKZV2heCP" target="_blank">Discord server</a> to report any bugs!</p>
        </div>
    </div>

    <!-- Zombie Selection Modal -->
    <div id="zombieSelectionModal">
        <div id="zombieSelectionContent">
            <h2>Select Zombies to Include</h2>
            <div id="zombieCategories"></div>
            <button onclick="applyZombieSelection()">Apply Selection</button>
            <button onclick="closeModal()">Cancel</button>
        </div>
        
    </div>

    <h4><a id="home" href="index.html">Home page</a></h4>
    


    <script>
        let violence = 1;
        let pool = [];
        let allZombies = {}; // Will store all zombies categorized by world
        let manualZombieSelection = [];
        let useManualSelection = false;

        function setMod(selectedMod) {
            mod = selectedMod;
            console.log('Selected mod:', mod);
            // You can call extraSpecials() or update other parts based on `mod`
        }

        document.addEventListener('DOMContentLoaded', () => {
        // Initialize difficulty from localStorage
        const difficultySelect = document.getElementById("difficulty");
        if (difficultySelect) {
            const savedDifficulty = localStorage.getItem('difficulty');
            if (savedDifficulty !== null) {
                difficultySelect.value = savedDifficulty;
            }
        }
        
        // Initialize all zombies data
        initializeAllZombies();
    });

    // Modify the openZombieSelection function
    function openZombieSelection() {
        useManualSelection = true;
        const modal = document.getElementById('zombieSelectionModal');
        const content = document.getElementById('zombieCategories');
        content.innerHTML = '';
        
        for (const [category, zombies] of Object.entries(allZombies)) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'zombie-category';
            
            const categoryHeader = document.createElement('h3');
            categoryHeader.textContent = category;
            categoryDiv.appendChild(categoryHeader);
            
            // Select all checkbox
            const selectAllDiv = document.createElement('div');
            const selectAllCheckbox = document.createElement('input');
            selectAllCheckbox.type = 'checkbox';
            selectAllCheckbox.id = `select-all-${category.replace(/\s+/g, '-')}`;
            selectAllCheckbox.onchange = function() {
                const checkboxes = categoryDiv.querySelectorAll('.zombie-checkbox input');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = this.checked;
                });
            };
            
            const selectAllLabel = document.createElement('label');
            selectAllLabel.htmlFor = selectAllCheckbox.id;
            selectAllLabel.textContent = 'Select All';
            
            selectAllDiv.appendChild(selectAllCheckbox);
            selectAllDiv.appendChild(selectAllLabel);
            categoryDiv.appendChild(selectAllDiv);
            
            // Zombie checkboxes
            zombies.forEach(zombie => {
                const zombieDiv = document.createElement('div');
                zombieDiv.className = 'zombie-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `zombie-${zombie}`;
                checkbox.value = zombie;
                checkbox.checked = manualZombieSelection.includes(zombie);
                
                const label = document.createElement('label');
                label.htmlFor = `zombie-${zombie}`;
                label.textContent = zombie;
                
                zombieDiv.appendChild(checkbox);
                zombieDiv.appendChild(label);
                categoryDiv.appendChild(zombieDiv);
            });
            
            content.appendChild(categoryDiv);
        }
        
        modal.style.display = 'block';
    }
    
    
        function initializeAllZombies() {
            allZombies = {
                "Ancient Egypt": [
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser", "explorer", "explorer_veteran"
                ],
                "Pirate Seas": [
                    "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler", "barrelroller_explosive", "pelican"
                ],
                "Wild West": [
                    "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer"
                ],
                "Future": [
                    "future_protector", "future_protector_generator", "future_jetpack", "future_jetpack_disco", "disco_mech", "football_mech", "mech_cone"
                ],
                "Dark Ages": [
                    "dark_wizard", "dark_juggler", "dark_king", "dark_explorer", "dark_wizard_veteran", "dark_wizard_veteran_vanilla", "dark_robber"
                ],
                "Big Wave Beach": [
                    "beach_fisherman_land", "beach_octopus", "beach_snorkel", "beach_surfer"
                ],
                "Lost City": [
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "lostcity_explorer"
                ],
                "Frostbite Caves": [
                    "iceage_charred", "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                    "iceage_dodo_veteran", "iceage_hunter_veteran", "iceage_weaselhoarder_veteran", "iceage_chief",
                    "iceage_chief_veteran", "iceage_troglobite_basic"
                ],
                "Jurassic Marsh": [
                    "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry", "dino_eggstealer"
                ],
                "Modern Day": [
                    "modern_newspaper", "modern_balloon", "modern_allstar", "tutorial_balloon", "modern_superfanimp",
                    "newspaper_veteran"
                ],
                "Steam Ages": [
                    "steam_furnace", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic", "steam_gargantuar_reg"
                ],
                "Roman World": [
                    "roman_medusa", "roman_healer", "roman_shield_pair", "roman_ballista"
                ],
                "80s World": [
                    "eighties_arcade", "eighties_arcade_basic", "eighties_boombox", "eighties_breakdancer_8bit",
                    "eighties_mc_8bit", "eighties_glitter_8bit", "eighties_punk_8bit"
                ],
                "Carnival": [
                    "carnie_cottoncandy_blue", "carnie_cottoncandy_pink", "carnie_trapeze_duo", "carnie_trapeze_quad",
                    "carnie_trapeze_trio", "carnie_stiltwalker", "carnie_firebreather", "carnie_cannon", "carnie_magician"
                ],
                "Halloween": [
                    "halloween_ghost", "halloween_witch", "halloween_relichunter", "halloween_octopus"
                ],
                "Zcorp": [
                    "zcorp_consultant", "zcorp_helpdesk", "zcorp_racer_chair"
                ],
                "Thanksgiving (Harvest)": [
                    "harvest_outhouse", "harvest_pitchfork", "harvest_eggstealer", "harvest_pterry"
                ],
                "Food Fight": [
                    "foodfight_gobbler_king", "foodfight_protector", "foodfight_chefster", "foodfight_overstuff"
                ],
                "Luck": [
                    "leprachaun_dodo", "stpatrick_ra", "stpatrick_punk", "stpatrick_glitter", "stpatrick_breakdancer_8bit", "stpatrick_ballista"
                ],
                "Feastivus": [
                    "feastivus_swashbuckler", "feastivus_poncho", "feastivus_camel_onehump", "feastivus_camel_twohump", 
                    "feastivus_camel_manyhump", "feastivus_troglobite", "feastivus_hunter", "feastivus_fisherman"
                ],
                "Miscellaneous": [
                    "general_treadmill_phase2", "spongebob_sniffer", "spongebob_superfanimp", "spongebob_newspaper", 
                    "spongebob_kelpyg", "april_underseer", "luan_juggler", "n3xt_duckytube", "n3xt_duckytube_fem", 
                    "n3xt_greaser", "n3xt_bowler", "n3xt_pigeonfeeder", "n3xt_pigeon", "n3xt_swinger", "spongebob_ourple", 
                    "spongebob_endo", "spongebob_endo_scary", "spongebob_allstar_ragdoll", "mashup_arcade_spongebob", 
                    "zombossmech_holiday_spongebob", "april_cowboy_gargantuar", "april_future_gargantuar", 
                    "april_barrelroller", "april_spring_prospector"
                ]
            };
        }


        function closeModal() {
            manualSelectionMode = false;
            document.getElementById('zombieSelectionModal').style.display = 'none';
        }

        function applyZombieSelection() {
        const checkboxes = document.querySelectorAll('#zombieCategories input[type="checkbox"]:not([id^="select-all-"])');
        manualZombieSelection = [];
        
        checkboxes.forEach(checkbox => {
            if (checkbox.checked) {
                manualZombieSelection.push(checkbox.value);
            }
        });
        
        if (manualZombieSelection.length > 0) {
            snackbar(`Selected ${manualZombieSelection.length} zombies for the pool.`);
            useManualSelection = true;
        } else {
            snackbar('No zombies selected. Using random selection.');
            useManualSelection = false;
        }
        
        closeModal();
    }

    function closeModal() {
        document.getElementById('zombieSelectionModal').style.display = 'none';
    }

    // Modified zombie pool generation
    function generateZombiePool() {
        if (useManualSelection && manualZombieSelection.length > 0) {
            // Start with manually selected zombies
            pool = [...manualZombieSelection];
            
            // Still add required zombies for difficulty
            if (difficulty >= 4 && !pool.includes("hero_zmech")) {
                pool.push("hero_zmech");
            }
        } else {
            // Original random selection logic
            let maxSpecials;
            if (difficulty === 1) maxSpecials = randint(2, 4);
            else if (difficulty <= 3) maxSpecials = randint(4, 20);
            else if (difficulty <= 6) maxSpecials = randint(10, 35);
            else if (difficulty <= 9) maxSpecials = randint(20, 60);
            else maxSpecials = randint(20, specials.length);
            
            let numSpecials = Math.min(randint(1, difficulty * 5), maxSpecials);
            pool = sample(specials, numSpecials);
            
            if (difficulty >= 4) {
                pool.push("hero_zmech");
                if (Math.random()*10 <= 50) {
                    pool.push(...sample(minibossPool, 5));
                }
            }
        }
        
        // [Rest of your existing pool generation logic]
        // Make sure to add checks for existing zombies when adding stage-specific ones
        // For example:
        if (stage === 'Iceage' && !pool.includes("iceage_armor3")) {
            pool.push("iceage_armor3");
        }
        
        // Final processing
        let basicPool = pool.toSpliced(4, pool.length);
        basicPool[0] = rtid(basicPool[0], 'ZombieTypes');
        basicPool[1] = rtid(basicPool[1], 'ZombieTypes');
        basicPool[2] = rtid(basicPool[2], 'ZombieTypes');
        basicPool[3] = rtid(basicPool[3], 'ZombieTypes');
        
        // Name normalization
        for (let i = 0; i < pool.length; i++) {
            if (pool[i] === 'n3xt') pool[i] = 'n3xt_basic';
            else if (pool[i] === 'n3xt_fem') pool[i] = 'n3xt_basic_fem';
            else if (pool[i] === 'summer') pool[i] = 'summer_basic';
        }
    }

        function generatePreview() {
            console.log("Generating preview...");
            console.log({ pool, cappedStartingPoints, cappedPointIncrement, plantfoodToSpawnCount, flags });

            let previewContainer = document.getElementById('levelPreview');
            previewContainer.innerHTML = ''; // Clear previous content

            // Remove duplicates from the pool array and clean up the RTID(@ZombieTypes) part
            let uniquePool = [...new Set(pool)];
            let cleanedPool = uniquePool.map(item => item.replace(/RTID\((.*?)@ZombieTypes\)/, '$1'));
            let poolDisplay = cleanedPool.length ? cleanedPool.join(', ') : 'No special pool defined';

            let variablesHTML = `
                <div class="inner-div">
                    <div class="variable-name">Special Pool</div>
                    <div class="variable-value">${poolDisplay}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Starting Points</div>
                    <div class="variable-value">${cappedStartingPoints}</div>
                    <div class="variable-name">Points Increment</div>
                    <div class="variable-value">${cappedPointIncrement}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Plant Food to Spawn</div>
                    <div class="variable-value">${plantfoodToSpawnCount}</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Stage</div>
                    <div class="variable-value">${stage}Stage</div>
                </div>
                <div class="inner-div">
                    <div class="variable-name">Flags</div>
                    <div class="variable-value">${flags}</div>
                </div>`;

            previewContainer.innerHTML = variablesHTML;
        }



        // Update difficulty and save to localStorage
        function updateDifficultyText(selectElement) {
            if (!selectElement) return;

            const difficultyText = selectElement.options[selectElement.selectedIndex]?.text || '';
            localStorage.setItem('difficulty', selectElement.value);

            console.log(`Selected difficulty: ${difficultyText}`);
            location.reload(); // Reload the page
        }

        let difficulty = localStorage.getItem('difficulty');
        let difficultyText = document.getElementById("difficulty").options[document.getElementById("difficulty").selectedIndex].text;
        if (localStorage.getItem('difficulty') != null){
            document.getElementById('difficulty').selectedIndex = localStorage.getItem('difficulty')
        }
        function updateDifficultyText(selectElement) {
        // Get the selected option text
        const difficultyText = selectElement.options[selectElement.selectedIndex].text;

        // Save the difficulty value to localStorage
        localStorage.setItem('difficulty', selectElement.value);

        // Update the display
        // Reload the page if needed
        reload();
    }

        function copyCode() {
            const text = JSON.stringify(level, null, 2); // Converts the object to a formatted JSON string
            navigator.clipboard.writeText(text);
            snackbar("Level code copied.");
        }
        function snackbar(text){
            var x = document.getElementById("snackbar")
            x.textContent = text;
            // Add the "show" class to DIV
            x.className = "show";

            // After 3 seconds, remove the show class from DIV
            setTimeout(function () { x.className = x.className.replace("show", ""); reload();}, 3000);
        }

        function startDownload() {
            // Get the filename from the input fields
            let filename = document.getElementById('filename').value;
            filename += document.getElementById('levelnum').value + '.json';
            text = JSON.stringify(level, null, 2);
            filename = filename.toLowerCase();

            // Convert the level object to a JSON string
            let dataStr = text;

            // Create a Blob object from the data string
            let dataBlob = new Blob([dataStr], { type: 'application/json' });

            // Create a URL for the Blob object
            let url = URL.createObjectURL(dataBlob);

            // Create a link element
            let link = document.createElement('a');
            link.download = filename;
            link.href = url;

            // Append the link to the body
            document.body.appendChild(link);

            // Simulate a click on the link
            link.click();

            // Remove the link from the body
            document.body.removeChild(link);

            snackbar('Level downloaded.')


        }


        let mod = localStorage.getItem('mod');
        if (mod == null) { mod = 'vnl' }
        document.getElementById('modOption').value = mod;

        function setMod(mod) {
            localStorage.setItem('mod', mod);
            reload();
        }

        function rtid(str, module) {
            return `RTID(${str}@${module})`;
        }


        let interval = Math.min(8,15);
        let minWaves = 3;
        let maxWaves = 5;

        // Formula to calculate flags based on difficulty
        let flags =randint(3,5);

        // Calculate the total based on interval and flags
        let total = interval * flags;

        function extraSpecials() {
            switch (mod) {
                case 'rfl':
                return [
                // Ancient Egypt
                "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser","explorer", "explorer_veteran", 

                // Pirate Seas
                "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler","barrelroller_explosive","pelican",

                // Wild West
                "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer",

                // Future
                "future_protector", "future_protector_generator", "future_jetpack", "future_jetpack_disco","disco_mech","football_mech"
                ,"mech_cone",

                // Dark Ages
                "dark_wizard", "dark_juggler", "dark_king", "dark_explorer","dark_wizard_veteran","dark_wizard_veteran_vanilla","dark_robber",


                // Big Wave Beach
                "beach_fisherman_land", "beach_octopus", "beach_snorkel", "beach_surfer",

                // Lost City
                "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "lostcity_explorer",

                // Frostbite Caves
                "iceage_charred", "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                "iceage_dodo_veteran", "iceage_hunter_veteran", "iceage_weaselhoarder_veteran", "iceage_chief",
                "iceage_chief_veteran", "iceage_troglobite_basic",

                // Jurassic Marsh
                "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry","dino_eggstealer",

                // Modern Day
                "modern_newspaper", "modern_balloon", "modern_allstar","tutorial_balloon","modern_superfanimp",
                "newspaper_veteran",

                // Steam Ages
                "steam_furnace", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic",

                // Roman World
                "roman_medusa", "roman_healer", "roman_shield_pair", "roman_ballista",

                // 80s World
                "eighties_arcade","eighties_arcade_basic","eighties_boombox","eighties_breakdancer_8bit",
                "eighties_mc_8bit", "eighties_glitter_8bit",
                "eighties_punk_8bit",
                // Carnival
                "carnie_cottoncandy_blue", "carnie_cottoncandy_pink", "carnie_trapeze_duo", "carnie_trapeze_quad",
                "carnie_trapeze_trio", "carnie_stiltwalker", "carnie_firebreather", "carnie_cannon", "carnie_magician",

                // Halloween
                "halloween_ghost","halloween_witch","halloween_relichunter","halloween_octopus",

                //Zcorp
                "zcorp_consultant","zcorp_helpdesk","zcorp_racer_chair",

                // Thanksgiving (Harvest)
                "harvest_outhouse", "harvest_pitchfork", "harvest_eggstealer", "harvest_pterry",

                // Food Fight
                "foodfight_gobbler_king","foodfight_protector","foodfight_chefster","foodfight_overstuff",
                // Luck
                "leprachaun_dodo","stpatrick_ra","stpatrick_punk","stpatrick_glitter","stpatrick_breakdancer_8bit","stpatrick_ballista",
                // Feastivus
                "feastivus_swashbuckler","feastivus_poncho","feastivus_camel_onehump","feastivus_camel_twohump","feastivus_camel_manyhump","feastivus_troglobite","feastivus_hunter",
                "feastivus_fisherman",
                // Miscellaneous
                "general_treadmill_phase2","spongebob_sniffer", "spongebob_superfanimp", "spongebob_newspaper", "spongebob_kelpyg", "april_underseer", "luan_juggler", "n3xt_duckytube", "n3xt_duckytube_fem", "n3xt_greaser", "n3xt_bowler", "n3xt_pigeonfeeder", "n3xt_pigeon", "n3xt_swinger", "spongebob_ourple", "spongebob_endo", "spongebob_endo_scary", "spongebob_allstar_ragdoll", "mashup_arcade_spongebob", "zombossmech_holiday_spongebob", "april_cowboy_gargantuar", "april_future_gargantuar", "april_barrelroller", "april_spring_prospector"
            ];
                    break;
                default:
                    return [];
                    break;
            }
        }

        function extraStages() {
            switch (mod) {
                case 'rfl':
                    return ['Summer',"Harvest","Xmas","Valentine","Paddys","Carnival","Hero","ModernPool","SpongebobGood","SpongebobShit","SpongebobMall","SpringFools","N3XTDave","N3XTCampgrounds","N3XTJungle","FNAF","HappyLand","Mesopotamia","Spongebob24Good","LunarSolar","LunarNebula","LunarVortex","LunarStardust"];
                    break;

                default:
                    return [];
                    break;
            }
        }
        let specials = []
        switch (mod) {
            case 'rfl':
            let specials = [
                // Ancient Egypt
                "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser","explorer", "explorer_veteran", 

                // Pirate Seas
                "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler","barrelroller_explosive","pelican",

                // Wild West
                "prospector", "west_bull", "west_bull_veteran", "poncho", "piano", "chicken_farmer",

                // Future
                "future_protector", "future_protector_generator", "future_jetpack", "future_jetpack_disco","disco_mech","football_mech"
                ,"mech_cone",

                // Dark Ages
                "dark_wizard", "dark_juggler", "dark_king", "dark_explorer","dark_wizard_veteran","dark_wizard_veteran_vanilla","dark_robber",


                // Big Wave Beach
                "beach_fisherman_land", "beach_octopus", "beach_snorkel", "beach_surfer",

                // Lost City
                "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter", "lostcity_explorer",

                // Frostbite Caves
                "iceage_charred", "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                "iceage_dodo_veteran", "iceage_hunter_veteran", "iceage_weaselhoarder_veteran", "iceage_chief",
                "iceage_chief_veteran", "iceage_troglobite_basic",

                // Jurassic Marsh
                "dino_bully", "dino_bully_veteran", "dino_bully_blue", "dino_pterry","dino_eggstealer",

                // Modern Day
                "modern_newspaper", "modern_balloon", "modern_allstar","tutorial_balloon","modern_superfanimp",
                "newspaper_veteran",

                // Steam Ages
                "steam_furnace", "steam_repairimp", "steam_inventor", "steam_gentleman", "steam_mechanic","steam_gargantuar_reg",


                // Roman World
                "roman_medusa", "roman_healer", "roman_shield_pair", "roman_ballista",

                // 80s World
                "eighties_arcade","eighties_arcade_basic","eighties_boombox","eighties_breakdancer_8bit",
                "eighties_mc_8bit", "eighties_glitter_8bit",
                "eighties_punk_8bit",

                // Carnival
                "carnie_cottoncandy_blue", "carnie_cottoncandy_pink", "carnie_trapeze_duo", "carnie_trapeze_quad",
                "carnie_trapeze_trio","carnie_trapeze_conga","carnie_stiltwalker", "carnie_firebreather", "carnie_cannon", "carnie_magician",

                // Halloween
                "halloween_ghost","halloween_witch","halloween_relichunter","halloween_octopus",
                //Zcorp
                "zcorp_consultant","zcorp_helpdesk","zcorp_racer_chair",

                // Thanksgiving (Harvest)
                "harvest_outhouse", "harvest_pitchfork", "harvest_eggstealer", "harvest_pterry",

                // Food Fight
                "foodfight_gobbler_king","foodfight_protector","foodfight_chefster","foodfight_overstuff",
                // Luck
                "leprachaun_dodo","stpatrick_ra","stpatrick_punk","stpatrick_glitter","stpatrick_breakdancer_8bit","stpatrick_ballista",
                // Feastivus
                "feastivus_swashbuckler","feastivus_poncho","feastivus_camel_onehump","feastivus_camel_twohump","feastivus_camel_manyhump","feastivus_troglobite","feastivus_hunter",
                "feastivus_fisherman",
                // Miscellaneous
                "general_treadmill_phase2","spongebob_sniffer","spongebob_armor5","spongebob_armor3", "spongebob_superfanimp", "spongebob_newspaper", "spongebob_kelpyg", "april_underseer", "luan_juggler", "n3xt_duckytube", "n3xt_duckytube_fem", "n3xt_greaser", "n3xt_bowler", "n3xt_pigeonfeeder", "n3xt_pigeon", "n3xt_swinger", "spongebob_ourple", "spongebob_endo", "spongebob_endo_scary", "spongebob_allstar_ragdoll", "mashup_arcade_spongebob", "zombossmech_holiday_spongebob", "april_cowboy_gargantuar", "april_future_gargantuar", "april_barrelroller", "april_spring_prospector"
            ];

            default:
                specials = [
                    "future_protector", "dark_wizard", "dark_juggler", "dark_king", "beach_octopus",
                    "iceage_hunter", "iceage_dodo", "iceage_weaselhoarder", "iceage_troglobite",
                    "camel_onehump", "camel_twohump", "camel_manyhump", "pharaoh", "ra", "tomb_raiser",
                    "explorer", "barrelroller", "cannon", "seagull", "pirate_captain", "swashbuckler","feastivus_swashbuckler",
                    "lostcity_impporter", "lostcity_excavator", "lostcity_jane", "lostcity_bug", "lostcity_bug_armor1",
                    "lostcity_bug_armor2", "lostcity_crystalskull", "lostcity_relichunter","feastivus_piano","feastivus_poncho",
                    "eighties_boombox", "dino_bully", "modern_newspaper", "modern_balloon", "modern_allstar",
                    "prospector", "west_bull", "poncho", "piano", "chicken_farmer", "mech_cone", "football_mech", "disco_mech", "future_jetpack", "future_jetpack_disco"
                ];
        }
        function createOptions(arr) {
            const selectElement = document.createElement('select');

            arr.forEach((value) => {
                const optionElement = document.createElement('option');
                optionElement.value = value;
                optionElement.textContent = value;
                selectElement.appendChild(optionElement);
            });

            return selectElement;
        }

        specials.push(...extraSpecials());
        let part ="spring";
        let bots = ["steam_clockwork","iceage_dodo_veteran","hero_zmech","steam_mechanic","steam_repairimp","future_imp","future_protector_generator","future_gargantuar","mech_cone","disco_mech","future_protector","west_bull","west_bull_veteran"]
        let basics = ["tutorial","duckytube","feastivus","valentines","carnie","eighties_8bit","roman", "mummy", "pirate", "cowboy", "future", "dark", "beach", "beach_fem", "iceage", "lostcity", "eighties", "dino", "summer", "zcorp", "zcorp_fem", "zcorp", "zcorp_fem","valentines","stpatrick", "steam_miner", "steam","spongebob","n3xt","n3xt_fem","happyland","spring",part, part, part, part, part, part, part, part,part, part, part, part, part, part, part, part,part, part, part, part, part, part, part, part];
        let imps = ["tutorial_imp", "egypt_imp", "pirate_imp", "future_imp", "dark_imp", "beach_imp", "iceage_imp", "lostcity_imp", "eighties_imp", "dino_imp", "steam_imp","spring_imp","leprachaun_imp","holiday_imp","feastivus_imp","valentines_imp","zcorp_imp","hero_impfinity","carnie_imp_twins"];
        let gargs = ["egypt_gargantuar","feastivus_gargantuar","valentines_gargantuar","stpatrick_gargantuar", "cowboy_gargantuar", "future_gargantuar", "dark_gargantuar", "beach_gargantuar", "iceage_gargantuar", "lostcity_gargantuar", "dino_gargantuar", "tutorial_gargantuar", "summer_gargantuar", "steam_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar","zcorp_gargantuar","carnie_gargantuar"]
        let validArmor4 = ["tutorial","duckytube","happyland","spongebob","carnie","iceage","eighties","beach","zcorp", "mummy", "pirate", "cowboy", "future", "dino", "dark"]
        
        let flyingUnits = ["lostcity_bug_armor2", "lostcity_bug_armor1", "modern_balloon", "tutorial_balloon", "future_jetpack_veteran", "future_jetpack", "pelican", "cannon", "lostcity_bug", "summer_bug", "summer_bug_armor1", "summer_bug_armor2", "future_jetpack_veteran", "spongebob_vi", "spongebob_vi_armor1", "spongebob_vi_armor2", "seagull", "steam_inventor"];
        let stage = ["Modern", "Egypt", "Pirate", "West", "Future", "Beach", "Iceage", "LostCity", "Eighties", "Dino"];
        stage.push(...extraStages());
        let stageBtn = localStorage.getItem('selectedStage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let select = document.getElementById('filename');
            let txt = stage[i];
            if (i == 2) { txt = 'Cowboy' }
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        function linearSearchAndRemove(array, element) {
            let index = array.indexOf(element);
            if (index !== -1) {
                array.splice(index, 1);
            }
            return array;
        }



        stage.unshift('random');
        let select = document.getElementById('stage');

        for (let i = 0; i < stage.length; i++) {
            let option = document.createElement('option');
            let txt = stage[i];
            option.setAttribute('value', txt);
            option.text = txt;
            select.appendChild(option);
        }

        select.addEventListener('change', function () {
            localStorage.setItem('selectedStage', this.value);
            reload();
        });
        stage.shift();
        if (stageBtn === 'random') {
            stage = choice(stage);
        }
        else stage = stageBtn;

        // Determine the max number of specials based on difficulty scaling
        let maxSpecials;
        if (difficulty === 1) { // Easy difficulty
            maxSpecials = randint(2, 4);
        } else if (difficulty <= 3) { // Normal difficulty (2-3)
            maxSpecials = randint(4, 20);
        } else if (difficulty <= 6) { // Insane difficulty (4-6)
            maxSpecials = randint(10, 35);
        } else if (difficulty <= 9) { // Crazy difficulty (7-9)
            maxSpecials = randint(20, 60);  
        } else { // Johan difficulty (10+)
            maxSpecials = randint(20, specials.length);
        }

        let numSpecials = Math.min(randint(1, difficulty * 5), maxSpecials);

        let minibossPool = [
            "hero_electricboogaloo",
            "hero_armor1",
            "hero_armor2",
            "hero_flag",
            "hero_disco_mech",
            "hero_impfinity",
            "hero_impfinity_zmech",
            "hero_neptuna",
            "hero_rustbolt",
            "hero_superbrainz",
            "hero_weaselhoarder",
            "hero_weasel",
            "hero_dodo",
            "hero_barrelroller",
            "hero_barrel",
            "hero_smash",
            "hero_mc",
            "hero_brainiac",
            "hero_glitter",
            "hero_stellar_glitter",
            "hero_bassloid",
            "hero_bass_basic",
            "hero_grate_mystery",
            "hero_steelwalker",
            "hero_captain_jones",
            "hero_bass"
        ];

        if (useManualSelection) {
            // Start with manually selected zombies
            pool = [...manualZombieSelection];
            
            // Still add hero_zmech for high difficulty if not already selected
            if (difficulty >= 4 && !pool.includes("hero_zmech")) {
                pool.push("hero_zmech");
            }
        } else {
            // Original random selection
            pool = sample(specials, numSpecials);
            
            // Add minibosses if not using manual selection
            if (difficulty >= 4) {
                pool.push("hero_zmech");
                if (Math.random()*10 <= 50) {
                    pool.push(...sample(minibossPool, 5));
                }
            }
        }

        let basicPool = pool.toSpliced(4, pool.length);
        basicPool[0] = rtid(basicPool[0], 'ZombieTypes');
        basicPool[1] = rtid(basicPool[1], 'ZombieTypes');
        basicPool[2] = rtid(basicPool[2], 'ZombieTypes');
        basicPool[3] = rtid(basicPool[3], 'ZombieTypes');
        if (stage === 'Hero'){
            pool = minibossPool;
        }
        // Name normalization
        for (let i = 0; i < pool.length; i++) {
            if (pool[i] === 'n3xt') {
                pool[i] = 'n3xt_basic';
            } else if (pool[i] === 'n3xt_fem') {
                pool[i] = 'n3xt_basic_fem';
            } else if (pool[i] === 'summer') {
                pool[i] = 'summer_basic';
            }
        }
        let table = document.createElement('table');
        table.style.width = '50%';
        table.style.margin = '0 auto'; // Center horizontally


        function addRow(cellType, text) {
            let row = document.createElement('tr'); // Create a new row
            let cell = document.createElement(cellType); // Create a new cell
            cell.textContent = text; // Set the cell's text content
            row.appendChild(cell); // Append the cell to the row
            table.appendChild(row); // Append the row to the table
        }








        function choice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function sample(arr, k) {
            let result = [];
            for (let i = 0; i < k; i++) {
                let randIndex = Math.floor(Math.random() * arr.length);
                result.push(arr[randIndex]);
                arr.splice(randIndex, 1);
            }
            return result;
        }

        function randint(min, max) {
            if (max < min) {
                [min, max] = [max, min]; // Swap min and max if max is less than min
            }
            // If min and max are equal, return that value
            if (min === max) {
                return min;
            }
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }


        function coinFlip() {
            return Math.random() >= 0.5;
        }

        var level = new Object();
        var objects = new Array();
        var objdata = new Object();
        var waveManager = new Object();
        let escalation = new Object();

        // Define weights for each jam event
        const jamWeights = {
            'jam_rap': 2,
            'jam_punk': 3,
            'jam_metal': 1,
            'jam_ballad': 1,
            'jam_8bit': 4,
            'jam_pop': 3
        };

        // Function to pick a weighted random jam event
        function weightedRandom(jamWeights) {
            const events = Object.keys(jamWeights);
            const weights = Object.values(jamWeights);
            
            // Calculate total weight
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            
            // Generate a random number between 0 and totalWeight
            const random = Math.random() * totalWeight;
            
            // Determine which event is selected
            let cumulativeWeight = 0;
            for (let i = 0; i < events.length; i++) {
                cumulativeWeight += weights[i];
                if (random < cumulativeWeight) {
                    return events[i];  // Return the selected event
                }
            }
        }
        let nonAmbush = ['West', 'Eighties', "Carnival", "ModernPool","SpongebobGood","SpongebobShit","SpongebobMall","SpringFools","N3XTDave","N3XTCampgrounds","N3XTJungle","FNAF","HappyLand","Mesopotamia","Spongebob24Good","LunarSolar","LunarNebula","LunarVortex","LunarStardust"];
        let j8bitstage = ["Paddys",'Modern'];
        // Function to add jam objects to the core structure
        function addJamObjects(stage) {
            
            const baseStructure = { 
                "aliases": [""], 
                "objclass": "SpawnZombiesJitteredWaveActionProps", 
                "objdata": { "NotificationEvents": [""] }
            };

            let selectedJamTypes;

            if (j8bitstage.includes(stage)) {
                selectedJamTypes = ['jam_8bit']; // Only 8bit jam for Paddys
            } else if (stage === 'Eighties') {
                selectedJamTypes = Object.keys(jamWeights); // Use all jams for Eighties
            } else {
                return; // Do nothing if stage isn't Eighties or Paddys
            }

            for (let jamType of selectedJamTypes) {
                let jamEvent = JSON.parse(JSON.stringify(baseStructure)); // Copy structure
                jamEvent.aliases[0] = jamType;
                jamEvent.objdata.NotificationEvents[0] = jamType;

                // Append the jam event
                objects.push(jamEvent);
            }
        }

        // Call the function to add jam objects based on the stage
        addJamObjects(stage);


        
        function waveArray() {
            let emptyWave = [];
            let waveOfEmptyWaves = [];

            for (let i = 1; i < total + 1; i++) {
                let jamEvent = null;
                
                if (nonAmbush.includes(stage) || j8bitstage.includes(stage)) {
                    // First wave should always be jam_8bit for Paddys
                    if (j8bitstage.includes(stage) && i === 1) {
                        jamEvent = 'jam_8bit';  // Only jam_8bit for the first wave in Paddys
                        if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                        waveOfEmptyWaves[i - 1].push(rtid(jamEvent, '.'));
                    } 
                    // Logic for Eighties stage (all waves get jam events)
                    else if (stage === 'Eighties') {
                        if (i % interval == 0 || (i % (interval / 2) == 0 || Math.random() < 0.1)) {
                            jamEvent = weightedRandom(jamWeights);
                            if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                            waveOfEmptyWaves[i - 1].push(rtid(jamEvent, '.'));
                        } else {
                            if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                        }
                    } else {
                        if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                    }
                } 

                // Logic for handling ambushes (always run for Paddys as well)
                if (j8bitstage.includes(stage) || !nonAmbush.includes(stage)) {
                    if (i % interval === 0) {
                        if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                        waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambush`, '.'));
                        ambush(i);
                        if (['Dark', 'Iceage', "Xmas"].includes(stage)) {
                            waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.'));
                        }
                    } else if (randint(1, 3) === 3) {
                        if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                        waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambush`, '.'));
                        ambush(i);
                        if (['Dark', 'Iceage', "Xmas", 'Beach'].includes(stage)) {
                            waveOfEmptyWaves[i - 1].push(rtid(`wave${i}ambushExtra`, '.'));
                        }
                    } else {
                        if (!waveOfEmptyWaves[i - 1]) waveOfEmptyWaves[i - 1] = [];
                    }
                }
            }

            return waveOfEmptyWaves;

        }




        let add_dinos = coinFlip()


        function dinoStage() {
            let k;
            // Extend switch to handle cases beyond 4 flags
            switch (flags) {
                case 1: k = randint(1, 2); break;
                case 2: k = randint(2, 3); break;
                case 3: k = randint(3, 5); break;
                case 4: k = 5; break;
                default: k = 5; break; // For any flags greater than 4, set k to the max 5 dinos
            }

            // Select dinos from the pool
            let dinos = sample(["raptor", "ptero", "stego", "tyranno", "ankylo"], k);
            let dinoboys =['dino_armor1','dino_armor2','dino_armor3','dino_bully']
            if ("ptero" in dinos && ! pool.includes(dinoboys)){
                pool.push('dino_armor1');
                pool.push('dino_armor2');
                pool.push('dino_armor3');
                pool.push('dino_bully_blue');
                pool.push('dino_bully');
            }

            // Create DinoWaveActionProps for each row (5 rows) and for the selected dinos
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < dinos.length; j++) {
                    append0({ "DinoRow": i, "DinoType": dinos[j] }, 'DinoWaveActionProps', `${dinos[j]}${i}`);
                }
            }

            // Initialize the waves or single wave based on stage
            if (stage === 'Modern') {
                var emptyWave = [];

                // Dino ambush logic for a single wave
                for (let j = 0; j < getViolence(1); j++) {
                    emptyWave.push(`${rtid(choice(dinos) + randint(0, 4), '.')}`);
                }

                return emptyWave;  // Return a single wave for Modern stage
            } else {
                var waveOfEmptyWaves = [];
                for (let i = 1; i <= total; i++) {
                    var emptyWave = [];

                    // Dino ambush logic for every interval-th wave and random waves
                    if (i % interval === 0 || randint(1, 3) === 3) {
                        for (let j = 0; j < getViolence(i); j++) {
                            emptyWave.push(`${rtid(choice(dinos) + randint(0, 4), '.')}`);
                        }
                    }

                    // Add the empty wave to the wave list
                    waveOfEmptyWaves.push(emptyWave);
                }

                return waveOfEmptyWaves;  // Return multiple waves for non-Modern stages
            }
        }





        function initialZombiePlacement(start, end, pool, num = randint(1, 10)) {
            let initialZombies = [];
            let cubabalezombies = ["iceage","iceage_armor1","iceage_armor2","iceage_armor4","iceage_armor3","iceage_dodo","iceage_imp","dino_eggshell","eighties_glitter_8bit","eighties_boombox",pool[randint(0,pool.length)],pool[randint(0,pool.length)],pool[randint(0,pool.length)]];
            pool = cubabalezombies;
            let occupied = new Set();  // Track occupied positions to avoid overlaps

            while (initialZombies.length < num) {
                let i = randint(0, 4);  // Row (Y-coordinate)
                let j = randint(start, end);  // Column (X-coordinate)
                let pos = { "GridX": j, "GridY": i };
                let posStr = JSON.stringify(pos);

                // Check if the position is already occupied
                if (!occupied.has(posStr)) {
                    occupied.add(posStr);

                    // If stage is 'Iceage', place frozen zombies
                    if (stage === 'Iceage' || stage === "Xmas") {
                        initialZombies.push({ ...pos, "TypeName": choice(pool), "Condition": "icecubed" });  // Always frozen
                    } 
                    if (stage === 'Modern') {
                        initialZombies.push({ ...pos, "TypeName": choice(pool), "Condition": "icecubed" });  // Always frozen
                    } 
                    else{
                        break;
                    }
                }
            }

            // Return the generated list of initial zombie placements
            let objdata = new Object();
            objdata.InitialZombiePlacements = initialZombies;
            append(objdata, "InitialZombieProperties", "IZY");
        }
        const easyPortalTypes = [
            "eighties", "eighties_modern41", "dino",
            "dino_modern41", "lostcity", "iceage", "iceage_hollows", "iceage_hollows_2",
            "beach", "dark", "dark_modern41", "future", "future_2", "future_3",
            "west", "west_modern41", "pirate", "pirate_modern41", "egypt",
            "egypt_2"
        ];

        const normalPortalTypes = [
            "holiday", "holiday_1", "holiday_2", "holiday_3", "holidays", "holidays_3",
            "steam_1", "steam_2","dangerroom_dino_2","egypt","beach"
        ];

        const hardPortalTypes = [
            "modern", "modern_1_modern41", "modern_2_modern41", "modern_3_modern41",
            "modern_4_modern41", "holiday_4",
            "holiday_5", "holiday_6", "holiday_7", "holiday_8", "holiday_9",
            "holiday_10", "holiday_11", "holiday_12",
            "dangerroom_holiday_1", "dangerroom_egypt", "dangerroom_egypt_new",
            "dangerroom_egypt_2", "dangerroom_pirate", "dangerroom_pirate_new",
            "dangerroom_pirate_2", "dangerroom_west", "dangerroom_west_new",
            "dangerroom_west_2", "dangerroom_future", "dangerroom_future_new",
            "dangerroom_future_2", "dangerroom_dark", "dangerroom_dark_new",
            "dangerroom_dark_2", "dangerroom_beach", "dangerroom_beach_new",
            "dangerroom_beach_2", "dangerroom_iceage", "dangerroom_iceage_new",
            "dangerroom_iceage_2", "dangerroom_lostcity", "dangerroom_lostcity_new",
            "dangerroom_lostcity_2", "dangerroom_eighties", "dangerroom_eighties_new",
            "dangerroom_eighties_2", "dangerroom_dino", "dangerroom_dino_new",
            
        ];

        const veteranPortalTypes = [
            "veteran_egypt", "veteran_pirate", "veteran_west", "veteran_eighties",
            "veteran_dino", "veteran_lostcity", "veteran_iceage", "veteran_beach",
            "veteran_dark", "veteran_future", "modern_rally", "eighties_8bit"
        ];
        function portalSpawn(wav) {
            let portals = [];
            let maxportal = randint(1,difficulty);
            let portalNum = 1;  // Default to 1 portal if not specified
            let violence = getViolence(wav);

            switch (violence) {
                case 0:
                    portals = [choice(easyPortalTypes)];
                    break;
                case 1:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(1, 2));
                    break;
                case 2:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(1, 3));
                    break;
                case 3:
                    portals = sample(easyPortalTypes.concat(normalPortalTypes), randint(3, 4));
                    portalNum = randint(0, 2);
                    break;
                case 4:
                    portals = sample(easyPortalTypes.concat(hardPortalTypes), randint(2, 4));
                    portalNum = randint(1, 3);
                    break;
                default:
                    portals = sample(hardPortalTypes.concat(veteranPortalTypes), randint(5, 9));
                    portalNum = randint(0,difficulty);
                    break;
            }
            portalNum=Math.min(portalNum,maxportal);
            return {portals,  portalNum};
        }

        // Function to create and configure the modern stage
        function modernStage() {
            const waveConfigs = Array(total).fill([]);  // Initialize waves as empty arrays
            let row, column;
            let portalCooldown = 0;  // Cooldown to prevent portals from spawning too often

            for (let waveIndex = 1; waveIndex < total; waveIndex++) {  // Start from wave 1
                if  (waveIndex === 1) {
                        jamEvent = 'jam_8bit';  // Only jam_8bit for the first wave in Paddys
                        waveConfigs[0] = ([rtid(jamEvent, '.')]);
                    } 
                let violence = getViolence(waveIndex) / 7;  // Scale violence

                // Coinflip decides whether to spawn rain, portals, or dinos
                let eventType = randint(0, 2);  // 0: Rain, 1: Portals, 2: Dinos

                if (eventType === 0) {
                    // Spawn rain for the wave
                    const rainConfig = modernRain(waveIndex);  // Generate the rain configuration
                    waveConfigs[waveIndex] = rainConfig;
                } else if (eventType === 1) {
                    // Spawn portals for the wave
                    const { portals, portalNum } = portalSpawn(violence);

                    // Adjust how often portals spawn by adding a cooldown and adjusting the threshold
                    let numPortalsToAdd = Math.min(10, portalNum); // Cap portal numbers
                    let portalThreshold = violence * 0.75;  // Make violence threshold higher to reduce portal spawn

                    // If portalCooldown is active, skip portal spawning this wave
                    if (portalCooldown > 0) {
                        portalCooldown--;
                        continue;
                    }

                    // Conditionally spawn portals based on violence level and cooldown
                    if ((waveIndex >= interval || violence >= Math.random()) && violence > portalThreshold) {
                        const wavePortals = generatePortals(waveIndex, portals, numPortalsToAdd);
                        waveConfigs[waveIndex] = wavePortals;
                        portalCooldown = randint(0, 3);  // Cooldown before portals can spawn again
                    }
                } else if (eventType === 2) {
                    // Spawn dinos for the wave
                    const dinoWave = dinoStage();  // Generate the dino configuration
                    
                    waveConfigs[waveIndex] = dinoWave;
                }
            }

            updateWaveManager(waveConfigs);  // Update wave manager with wave configurations
        }
        function modernRain(wave) {
            var num = 0;
            var start = 0;
            var end = 0;
            var time = 0;
            let violence = getViolence(wave);

            switch (violence) {
                case 0:
                    time = 1.5;
                    start = 6;
                    end = 8;
                    num = randint(1, 2);
                    break;
                case 1:
                    time = 1.25;
                    start = 5;
                    end = 7;
                    num = randint(0, 4);
                    break;
                case 2:
                    time = 1.05;
                    start = 3;
                    end = 6;
                    num = randint(4, 5);
                    break;
                case 3:
                    time = 1;
                    start = 3;
                    end = 6;
                    num = randint(3, 7);
                    break;
                case 4:
                    time = 0.5;
                    start = 2;
                    end = 6;
                    num = randint(5, difficulty);
                    break;
                default:
                    time = 0.25;
                    start = 2;
                    end = 6;
                    num = randint(3, difficulty);
            }

            let objclass, name, message;

            objclass = choice(['SpiderRainZombieSpawnerProps','ParachuteRainZombieSpawnerProps']);
            if (objclass =='SpiderRainZombieSpawnerProps'){

                
                let impType = ['modern_superfanimp', 'tutorial_imp', 'future_imp',choice(imps)][Math.floor(Math.random() * 3)];
                name = impType;
                // Determine the name and message based on the imp type
                if (impType === 'modern_superfanimp') {
                    message = 'Bomb Imp!';
                } else if (impType === 'tutorial_imp') {
                    message = 'Imp Rain!';
                } else if (impType === 'future_imp') {
                    message = Math.random() < 0.5 ? 'Fallen Technology' : 'Spider Rain';
                    message = `${message}!`;
                }
                else{
                    message = 'Bag of imps !';
                }
            }
            else{
                name = choice(['lostcity_lostpilot',"zcorp_helpdesk"])
                    if (name == "zcorp_helpdesk"){
                        message = 'inzanity support!'
                    }
                    else {
                        message = 'Parachute Rain!'
                    }
            }

            // Create rain configuration object
            let rainConfig = {
                ColumnStart: start,
                ColumnEnd: end,
                SpiderCount: num,
                TimeBetweenGroups: `${time}`,
                ZombieFallTime: `${time}`,
                SpiderZombieName: name,
                WaveStartMessage: message
            };

            append0(rainConfig, objclass, `wave${wave}ambush`);

            // Properly return the correct RTID format without extra quotes
            return [`RTID(wave${wave}ambush@.)`];
        }



        function generatePortals(waveIndex, portals, numPortals) {
            const wavePortals = [];

            for (let i = 0; i < numPortals; i++) {
                const row = randint(0, 4);
                const column = randint(4, 8);
                const portalId = `PortalSpawn${waveIndex}_${column}${row}`;

                wavePortals.push(`RTID(${portalId}@.)`);

                // Append new portal configuration for spawning
                append0({
                    "PortalColumn": column,
                    "PortalRow": row,
                    "PortalType": portals[randint(0, portals.length - 1)],
                }, 'SpawnModernPortalsWaveActionProps', portalId);
            }

            return wavePortals;
        }






        function updateWaveManager(waveConfigs) {
            append0({
                "Waves": waveConfigs
            }, 'WaveManagerProperties', 'WaveManager');
        }





        function sample(arr, k) {
            let result = [];
            for (let i = 0; i < k; i++) {
                let randIndex = Math.floor(Math.random() * arr.length);
                result.push(arr[randIndex]);
                arr.splice(randIndex, 1);
            }
            return result;
        }

        function getWaveManagerConfig() {
            return { "objdata": { "Waves": [] } };
        }

        function setWaveManagerConfig(config) {
            console.log("WaveManager configuration updated:", config);
        }


        function getViolence(wave) {
            if (wave < 3) {
                return 1;
            } else if (wave < 6) {
                return randint(1, 2);
            } else if (wave < 10) {
                return randint(2, 3);
            } else if (wave < 16) {
                return randint(4, 6);
            }
            else return randint(1, 8);
        }

        let cappedStartingPoints = randint(150, Math.pow(difficulty, 2) * 50);
        let cappedPointIncrement = randint(150, Math.pow(difficulty, 2) * 55);
        console.log(cappedPointIncrement)



        let plantfoodToSpawnCount =randint(3,difficulty);


        
        escalation.FlagCount = flags;
        escalation.WavesPerFlag = interval;
        escalation.PlantfoodToSpawnCount = plantfoodToSpawnCount;  
        escalation.StartingPoints = cappedStartingPoints;
        escalation.PointIncrementPerWave = cappedPointIncrement;
        escalation.WaveManagerProps = "RTID(WaveManager@CurrentLevel)";

        if (pool.length > 20) {
            pool = pool.slice(0, 20);
        }

        escalation.ZombiePool = pool;





        var modules = [];

        function append(objdata, objclass, alias) {
            let obj = new Object();
            if (!(alias === undefined)) {
                obj.aliases = [alias];
                modules.push(`RTID(${alias}@.)`);
            }
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        function append0(objdata, objclass, alias) {
            let obj = new Object();
            obj.aliases = [alias];
            obj.objclass = objclass;
            obj.objdata = objdata;
            objects.push(obj);
        }

        modules.push("RTID(StandardIntro@LevelModules)");
        modules.push("RTID(ZombiesDeadWinCon@LevelModules)");
        modules.push("RTID(DefaultZombieWinCondition@LevelModules)");
        modules.push("RTID(ChallengeSeedBank@LevelModules)");
        let mowers = false;
        if (coinFlip()) {
            if (stage == "Harvest" || stage == "Summer" || stage == "Xmas" || stage == "Paddys" || stage == "Spring" || stage == "Valentine" || stage == "Hero"){
                modules.push(`RTID(HolidayMowers@LevelModules)`) ;
            }
            else {
                modules.push(`RTID(${stage}Mowers@LevelModules)`) ;
            }
            
            mowers = true;
             
        }

        if (stage !== 'Dark' && stage !== 'Summer' && stage !== 'Carnival'){
            
            modules.push("RTID(DefaultSunDropper@LevelModules)") ;
        };

        objdata.StartingSun = randint(1, 4) * 25;
        objdata.Description = "Inszanity on a next level";
        objdata.Loot = "RTID(DefaultLoot@LevelModules)";
        objdata.Modules = modules;
        objdata.Name = choice([
        "Inzanity awaits -", 
        "Supreme Inzanity -", 
        "Brace for the horde -", 
        "Plankton tip: Use Winter Melon to melt the horde -", 
        "This is far from endless -", 
        "The madness begins -", 
        "Meltdown imminent -", 
        "Zombies rising -", 
        "Survival at its peak -", 
        "There is a zombie on your lawn ! -", 
        "Conquer the horde -", 
        "Winter Melon saves the day -", 
        "Doomed from the start -", 
        "Zombot's sanity -", 
        "The last stand -",
        "ballz -",
        "being banned sucks -",
        "a COOL invasion -",
        "no idea for level name -",
        "A lucky generation -"
    ]) + " " + stage;

        if (difficulty > 3) {
            if (stage === "Iceage") {
                objdata.StageModule = `RTID(${stage}VeteranStage@LevelModules)`;
                objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`, `MiniGame_MiniBoss`])
            }
            if (stage === 'Modern' ) {
                objdata.StageModule = `RTID(${stage}NightStage@LevelModules)`;
                objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`]);
            }
            if (stage === 'Harvest' ){
                objdata.MusicType = choice([`MiniGame_MiniBoss`])
                objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
            }
            else {
                objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
                if (coinFlip()) {
                    objdata.MusicType = choice([`MiniGame_B`, `MiniGame_A`]);
                }
                
            }
        if (stage === 'Modern' ) {
            objdata.StageModule = `RTID(${stage}AllJamsStage@LevelModules)`;
        }
        } else {
            objdata.StageModule = `RTID(${stage}Stage@LevelModules)`;
            modules.push("RTID(DefaultSunDropper@LevelModules)") ;
        }
        if (stage === 'Modern') {
            objdata.ResourceGroupNames = [
                "DelayLoad_Background_Beach",
                "DelayLoad_Background_Beach_Compressed",
                "Tombstone_Dark_Special",
                "Tombstone_Dark_Effects"
            ]
        }



        waveManager.FlagWaveInterval = interval;
        waveManager.WaveCount = total;
        waveManager.SuppressFlagZombie = false;
        waveManager.MinNextWaveHealthPercentage = 0.5;
        waveManager.MaxNextWaveHealthPercentage = 0.75;

        append(objdata, 'LevelDefinition');
        append({}, "WaveManagerModuleProperties", "NewWaves");
        append(escalation, "LevelEscalationModuleProperties", "Escalation");

        if (stage == 'Dino') { waveManager.Waves = dinoStage() }
        else if (stage == 'Modern') {
             waveManager.Waves = modernStage();
        }
        else waveManager.Waves = waveArray();
        if (stage == "Carnival") {
            append(
                {
                    "RandomPostersLeft": [
                        "IMAGE_BACKGROUNDS_CARNIVAL_POSTER_BASICS_LEFT",
                        "IMAGE_BACKGROUNDS_CARNIVAL_POSTER_POTATOCHIP_LEFT"
                    ],
                    "RandomPostersRight": [
                        "IMAGE_BACKGROUNDS_CARNIVAL_POSTER_BASICS_RIGHT",
                        "IMAGE_BACKGROUNDS_CARNIVAL_POSTER_POTATOCHIP_RIGHT"
                    ],
                    "UseRandomPosters": true
                },
                "CarniePosterModuleProperties",
                "CarnieLevelGenPosterModule"
            );

            modules.push("RTID(CarnieLevelGenPosterModule@.)");
        }
        append(waveManager, "WaveManagerProperties", "WaveManager");

        level.objects = objects;
        level.version = 1;
        let occupied = new Set();

        switch (stage) {
            case 'Egypt':
                chessboard(2, 8, ['gravestone_egypt']);
                break;
            case 'Carnival':
                createPattern(0, 8, ["carnie_card_sunify", "carnie_card_PFify", "carnie_card_basic", "carnie_card_armor2", "carnie_card_armor4"]);
                break;
            case 'Paddys':
                createPattern(0, 8, ["gravestone_tutorial","gravestone_tutorial","gravestone_tutorial","gravestone_tutorial","gravestone_tutorial","goldtile","goldtile","presentPlantOnDestruction","presentZombieOnDestruction","presentZombieOnDestruction","presentZombieOnDestruction"]);
                break;
            case 'Modern':
                if (coinFlip()){
                    initialZombiePlacement(3, 7, pool, randint(2, 3));
                }
                if (coinFlip()){
                    railCarts();
                }
                if (coinFlip()){
                chessboard(1, 8, ['goldtile','tar','goldtile','goldtile','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','surfboard', 'gravestoneSunOnDestruction','bufftile_attack','bufftile_speed','bufftile_shield']);
                }
                else{
                    createPattern(1, 8, ['goldtile','tar','goldtile','goldtile','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','gravestone_tutorial','surfboard', 'gravestoneSunOnDestruction','bufftile_attack','bufftile_speed','bufftile_shield'],randint(3,11));
                }
                break;
            case 'Pirate':
                append({ "PlankRows": sample([0, 1, 2, 3, 4], randint(1, 5)).sort() }, "PiratePlankProperties", "PiratePlanks");
                pool.push(...sample(flyingUnits, randint(2, 4)));
                break;
            case 'West':
                railCarts();
                break;
            case 'Valentine':
                createPattern(0, 8, ["presentSunOnDestruction_valentines","presentPlantfoodOnDestruction_valentines","presentPlantOnDestruction_valentine","presentZombieOnDestruction_valentines","holidaydrink_valentines"]);
                break;
            case 'Spring':
                createPattern(3, 8, ["gravestone_tutorial","holidaydrink_spring"]);
                break;
            case 'Spring':
                createPattern(3, 8, ["gravestone_tutorial","holidaydrink_heroes"]);
                break;
            case 'Harvest':
                createPattern(0,8,["pumpkin_scarecrow","crater",'presentSunOnDestruction','presentPlantfoodOnDestruction','presentPlantOnDestruction','presentPlantOnDestruction_valentines']);
                if (coinFlip()){
                    railCarts();
                }
                
                break;
            case 'Summer':
                chessboard(3, 7, ["fireworks","holidaydrink_summernights", 'speaker','presentSunOnDestruction','presentPlantfoodOnDestruction','presentPlantOnDestruction','presentPlantOnDestruction_valentines']);
                break;
            case 'Xmas':
                chessboard(3, 7, ['presentSunOnDestruction','presentPlantfoodOnDestruction','presentPlantOnDestruction']);
                break;
            case 'Future':
                let diceRoll = randint(1, 3); // Random number of power tiles
                let latinPower = ['alpha', 'beta', 'gamma', 'delta'];
                let strPower = 'powertile_';

                // Pick random latin letters for power tiles
                latinPower = sample(latinPower, diceRoll);

                // Buff tile types
                let latinBuff = ['attack', 'speed', 'shield'];
                let strBuff = 'bufftile_';
                let diceRollBuff = randint(1, 2);
                latinBuff = sample(latinBuff, diceRollBuff);

                // Combined grid placements for both power and buff tiles
                var InitialGridItemPlacements = [];

                // Iterate and place both power tiles and buff tiles
                for (let i = 0; i < latinPower.length; i++) {
                    // Power tile placement
                    InitialGridItemPlacements.push(...powertileBoard(0, 6, strPower + latinPower[i], randint(2, 5)));

                    // Buff tile placement at the same position
                    if (i < latinBuff.length) {
                        InitialGridItemPlacements.push(...bufftileBoard(6, 8, strBuff + latinBuff[i], randint(2, 5)));
                    }
                }

                // Single object to store both power and buff tile placements
                var obj = new Object();
                obj.InitialGridItemPlacements = InitialGridItemPlacements;

                // Append to the 'GI' module just once
                append(obj, 'InitialGridItemProperties', 'GI');
                break;

            case 'Dark':
                chessboard(2, 8, ['gravestone_dark', 'gravestone_dark', 'gravestoneSunOnDestruction']);
                break;
            case 'Beach':
                let columns = [9, 8, 7, 6, 5, 4];
                let index = randint(0, 5);

                // Add Initial Tide setup
                append({
                    "StartingWaveLocation": columns[index],  // Random column for the tide to start
                    "ShowTideMarker": true                   // Show the tide marker
                }, "TideProperties", "InitialTide");

                // Add beach grid items (e.g., surfboard and lilypad) for visual and gameplay elements
                chessboard(3, 6, ['surfboard', 'lilypad'], randint(2, 4));

                break;
            case 'Iceage':
                chessboard(3, 7, ['gravestone_iceage'], randint(4, 5));
                initialZombiePlacement(3, 7, pool, randint(4, 6));
                break;
            case 'Dino':
                chessboard(1, 8, ['crater', 'tar', 'rock'], randint(3, 7));
                break;
            case 'Eighties':
                chessboard(2, 8, ['eightiesarcadecabinet', 'bufftile_shield','bufftile_speed', 'speaker', 'speaker', 'speaker'], randint(4, 7));
                break;
            case 'LostCity':
                chessboard(0, 5, ['goldtile', 'goldtile', 'goldtile', 'gravestone_lostcity', 'boulder_trap_falling_forward', 'flame_spreader_trap'], randint(1, 7));
            default:
                break;
        }

        for (let i = 0; i < pool.length; i++) {
            pool[i] = `RTID(${pool[i]}@ZombieTypes)`;
        }
        pool.pop()

        window.onload = function () {
            let filename = localStorage.getItem('filename');
            let levelnum = localStorage.getItem('levelnum');
            let selectedStage = localStorage.getItem('stage');

            let stageSelect = document.getElementById('stage');
            let select = document.getElementById('filename');
            if (filename !== null) {
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === filename) {
                        select.selectedIndex = i;
                        break;
                    }
                }
            }
            if (selectedStage !== null) {
                for (let i = 0; i < stageSelect.options.length; i++) {
                    if (stageSelect.options[i].value === selectedStage) {
                        stageSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            let num = document.getElementById('levelnum');
            if (levelnum !== null) {
                num.value = levelnum;
            }
        }

        // Save the selected values and reload the page

        function reload() {
            let num = document.getElementById('levelnum');
            let filename = document.getElementById('filename');
            let stageElement = document.getElementById('stage');
            localStorage.setItem('levelnum', num.value);
            let selectedFilename = filename.options[filename.selectedIndex].value;
            let selectedStage = stageElement.options[stageElement.selectedIndex].value;
            localStorage.setItem('filename', selectedFilename);
            localStorage.setItem('stage', selectedStage);
            location.reload();
        }
        function updateDifficultyText(selectElement) {
        if (!selectElement) return;

        const difficultyText = selectElement.options[selectElement.selectedIndex]?.text || '';
        localStorage.setItem('difficulty', selectElement.value);
        console.log(`Selected difficulty: ${difficultyText}`);

        reload(); // Refresh the page
        }




        // Debug function to find index by alias
        function findIndexWithAlias(objects, targetAlias) {
            const index = objects.findIndex(obj =>
                obj.aliases && Array.isArray(obj.aliases) && obj.aliases.includes(targetAlias)
            );
            return index;
        }

        // Debug function to find index by class
        function findIndexWithClass(objects, targetClass) {
            const index = objects.findIndex(obj => obj.objclass === targetClass);
            return index;
        }
        function createPattern(start, end, typeName, num = randint(1,11)) {
            const patterns = [
                // Pattern 1: 5 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 1, TypeName: null },
                    { GridX: 0, GridY: 2, TypeName: null },
                    { GridX: 0, GridY: 3, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 2: 3 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 2, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 3: 2 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 4: 1 grid point
                [
                    { GridX: 0, GridY: 2, TypeName: null },
                ],
                // Pattern 5: 4 grid points
                [
                    { GridX: 0, GridY: 3, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                    { GridX: 0, GridY: 1, TypeName: null },
                    { GridX: 0, GridY: 0, TypeName: null },
                ],
            ];

            let grids = [];
            let occupiedX = new Set(); // Tracks occupied GridX values

            // Create an array of X positions for each pattern (ensuring they are unique)
            let xPositions = [];
            while (xPositions.length < num) {
                let randomX = randint(start, end); // Random X between start and end
                if (!xPositions.includes(randomX)) { // Ensure uniqueness of X positions
                    xPositions.push(randomX);
                }
            }

            // Count total number of grid items
            let totalGridItems = 0;

            // Place grid items based on the number of patterns and their specific X values
            for (let i = 0; i < xPositions.length && totalGridItems < num; i++) {
                let randomX = xPositions[i]; // Get the X position for this iteration
                let pattern = patterns[Math.floor(Math.random() * patterns.length)]; // Pick a random pattern

                // For each item in the selected pattern, assign the same X but keep GridY as is
                for (let item of pattern) {
                    if (totalGridItems >= num) break; // Stop if we exceed the num limit

                    let pos = { GridX: randomX, GridY: item.GridY, TypeName: typeName[Math.floor(Math.random() * typeName.length)] };
                    grids.push(pos);
                    totalGridItems++; // Increment the total grid items counter
                }
            }

            // Finalize grid placements
            let objdata = {};
            objdata.InitialGridItemPlacements = grids;
            append(objdata, "InitialGridItemProperties", "GI");
        }




        


        function chessboard(start, end, typeName, num = randint(3, 16)) {
            let grids = [];
            let occupied = new Set();
            let columnSliders = {};  // Tracks sliders in each column for backward connection checking

            // Helper function to check if there's a valid path leading back to a previous slider
            function isValidSliderPlacement(gridX, gridY, sliderType) {
                if (sliderType === 'slider_up' && gridY === 0) {
                    return false;  // Can't place slider up in Y = 0
                }
                if (sliderType === 'slider_down' && gridY === 4) {
                    return false;  // Can't place slider down in Y = 4
                }

                // Ensure that no other sliders are in conflicting rows for vertical sliders
                if (sliderType === 'slider_up') {
                    for (let y = gridY - 1; y >= 0; y--) {
                        let conflictingSlider = columnSliders[gridX] ? columnSliders[gridX].find(slider => slider.GridY === y) : null;
                        if (conflictingSlider) {
                            return false;  // Conflict with an existing slider
                        }
                    }
                } else if (sliderType === 'slider_down') {
                    for (let y = gridY + 1; y <= 4; y++) {
                        let conflictingSlider = columnSliders[gridX] ? columnSliders[gridX].find(slider => slider.GridY === y) : null;
                        if (conflictingSlider) {
                            return false;  // Conflict with an existing slider
                        }
                    }
                }

                return true;  // No conflicts, valid placement
            }

            // Place grid items
            while (grids.length < num) {
                let i = randint(0, 4);  // Row (Y-coordinate)
                let j = randint(start, end);  // Column (X-coordinate)
                let pos = { "GridX": j, "GridY": i };
                let posStr = JSON.stringify(pos);
                let validSliderPlacement = true;

                if (!occupied.has(posStr)) {
                    // Modern and Iceage stages allow sliders and grid items
                    if (stage === 'Modern' || stage === 'Iceage') {
                        let randomType = Math.random();
                        let shouldPlaceSlider = randomType < 0.3;  // 30% chance to place a slider

                        if (shouldPlaceSlider) {
                            let sliderType;

                            // Determine slider direction
                            if (randomType < 0.15) {
                                sliderType = (stage === 'Modern') ? 'slider_down_modern' : 'slider_down';  // Slider Down
                                validSliderPlacement = isValidSliderPlacement(j, i, sliderType);  // Check if it's valid
                                if (i === 4) validSliderPlacement = false;  // Can't place slider down in Y = 4
                            } else {
                                sliderType = (stage === 'Modern') ? 'slider_up_modern' : 'slider_up';  // Slider Up
                                validSliderPlacement = isValidSliderPlacement(j, i, sliderType);  // Check if it's valid
                                if (i === 0) validSliderPlacement = false;  // Can't place slider up in Y = 0
                            }

                            // Place slider if valid
                            if (validSliderPlacement) {
                                grids.push({ ...pos, "TypeName": sliderType });
                                if (!columnSliders[j]) columnSliders[j] = [];
                                columnSliders[j].push(pos);  // Track slider in column
                                occupied.add(posStr);
                            }

                        } else {
                            // Place regular grid item
                            grids.push({ ...pos, "TypeName": choice(typeName) });
                            occupied.add(posStr);
                        }

                    } else {
                        // For other stages, place normal grid items from typeName
                        grids.push({ ...pos, "TypeName": choice(typeName) });
                        occupied.add(posStr);
                    }
                }
            }

            // Finalize grid placements
            let objdata = {};
            objdata.InitialGridItemPlacements = grids;
            append(objdata, "InitialGridItemProperties", "GI");
        }






        function powertileBoard(start, end, typeName, num) {
            // Predefined grid patterns
            const patterns = [
                // Pattern 1: 5 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 1, TypeName: null },
                    { GridX: 0, GridY: 2, TypeName: null },
                    { GridX: 0, GridY: 3, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 2: 3 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 2, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 3: 2 grid points
                [
                    { GridX: 0, GridY: 0, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                ],
                // Pattern 4: 1 grid point
                [
                    { GridX: 0, GridY: 2, TypeName: null },
                ],
                // Pattern 5: 4 grid points
                [
                    { GridX: 0, GridY: 3, TypeName: null },
                    { GridX: 0, GridY: 4, TypeName: null },
                    { GridX: 0, GridY: 1, TypeName: null },
                    { GridX: 0, GridY: 0, TypeName: null },
                ],
            ];

            let grids = [];
            let patternIndex = 0;  // Start from the first pattern

            // Iterate until we've placed the desired number of grid items
            while (grids.length < num) {
                // Get the current pattern
                let pattern = patterns[patternIndex];

                // For each grid item in the selected pattern
                for (let item of pattern) {
                    if (grids.length >= num) break; // Stop if we've reached the target number of grid items

                    // Randomize the X position within the given range
                    let randomX = randint(start, end);

                    // Place grid item with random X and pattern's GridY
                    grids.push({ GridX: randomX, GridY: item.GridY, TypeName: typeName });

                }

                // Move to the next pattern
                patternIndex = (patternIndex + 1) % patterns.length;
            }

            return grids;
        }


        // Buff tile spawns on the far edge, always at x = 8
        function bufftileBoard(start, end, typeName, num) {
            let grids = [];
            while (grids.length < num) {
                let i = randint(0,4);
                let j = randint(start, end);
                if (grids.length < num) {
                    let pos = { "GridX": j, "GridY": i };
                    grids.push({ ...pos, "TypeName": typeName });  // Allowing overlap
                }
            }
            return grids;
        }

        function railCarts() {
            let objdata = new Object();

            // Available minecart types
            let railcartTypes = [
                "railcart_cowboy",   // Cowboy
                "railcart_future",   // Future
            ];

            // Randomly select a railcart type for this wave
            objdata.RailcartType = sample(railcartTypes, 1)[0];

            let rails = [];
            let carts = [];
            let cartCount = 0;  // Track the total number of railcarts

            for (let i = 0; i < 8; i++) {
                if (cartCount >= 4) break;  // Stop if the max of 4 railcarts is reached

                var diceRoll = randint(1, 6);
                var rows = sample([0, 1, 2, 3, 4], 2);
                var end = Math.max(...rows);
                var start = Math.min(...rows);

                switch (diceRoll) {
                    case 1:
                    case 6:
                        continue;
                    case 2:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                            carts.push({ "Column": i, "Row": randint(0, 4) });
                            cartCount++;
                        }
                        break;
                    case 3:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": end, "RowStart": start, "Column": i });
                            carts.push({ "Column": i, "Row": randint(start, end) });
                            cartCount++;
                        }
                        break;
                    case 4:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 3, "Column": i });
                            rails.push({ "RowEnd": 1, "RowStart": 0, "Column": i });

                            if (cartCount < 4) {
                                carts.push({ "Column": i, "Row": randint(3, 4) });
                                cartCount++;
                            }
                            if (cartCount < 4) {
                                carts.push({ "Column": i, "Row": randint(0, 1) });
                                cartCount++;
                            }
                        }
                        break;
                    case 5:
                        if (cartCount < 4) {
                            rails.push({ "RowEnd": 4, "RowStart": 0, "Column": i });
                            carts.push({ "Column": i, "Row": start });
                            cartCount++;
                        }
                        if (cartCount < 4) {
                            carts.push({ "Column": i, "Row": end });
                            cartCount++;
                        }
                        break;
                    default:
                        break;
                }
            }

            objdata.Rails = rails;
            objdata.Railcarts = carts;
            append(objdata, "RailcartProperties", "CowboyRails");
        }
        function stormAmbush(wave, type) {
            let violence= getViolence(wave);
            let pool = [];
            var basic, imp, conhead, buckethead,randm, brickhead, garg;
            switch (type) {
                case 'sand':
                    basic = "mummy";
                    imp = "egypt_imp";
                    randm = choice(pool);
                    conehead = "mummy_armor1";
                    buckethead = "mummy_armor2";
                    brickhead = "ra";
                    garg = "tomb_raiser";
                    break;
                case 'dark':
                    basic = { "Type": "RTID(dark@ZombieTypes)" };
                    conehead = { "Type": "RTID(dark_armor1@ZombieTypes)" };
                    buckethead = { "Type": "RTID(dark_armor2@ZombieTypes)" };
                    brickhead = { "Type": "RTID(dark_armor3@ZombieTypes)" };
                    imp = { "Type": "RTID(dark_imp@ZombieTypes)" };
                    garg = { "Type": "RTID(dark_gargantuar@ZombieTypes)" };
                    break;
                case 'snow':
                    basic = "iceage";
                    randm = choice(pool);
                    conehead = "iceage_armor1";
                    buckethead = "iceage_armor2";
                    brickhead = "iceage_armor3";
                    imp = "iceage_imp";
                    garg = "iceage_dodo";
                    break;
                case 'eighties':
                default:
                    imp = "zcorp_imp"
                    garg = "zcorp_gargantuar";;
                    break;
            }
            let start = 1;
            let num = 0;
            let end = 0;

            switch (violence) {
                case 0: // Low violence, fewer zombies
                    pool = [basic];
                    start = 4;
                    end = 8;
                    num = 1;
                    break;
                case 1:
                    pool = [basic, imp, conehead];
                    start = 4;
                    end = 7;
                    num = randint(1, 3);
                    break;
                case 2:
                    pool = [basic, imp, conehead, buckethead];
                    start = 4;
                    end = 7;
                    num = randint(1, 4);
                    break;
                case 3:
                    pool = [imp, conehead, buckethead, garg];
                    start = 3;
                    end = 6;
                    num = randint(1, 5);
                    break;
                case 4: // High violence, more zombies
                default:
                    pool = [buckethead, brickhead, imp, garg];
                    start = 4;
                    end = 6;
                    num = randint(1, difficulty);
                    break;
            }

            // Add object data for spawning storm zombies
            let objdata = {
                AdditionalPlantfood: 0,
                Type: `${type}storm`,
                ColumnStart: start,
                ColumnEnd: end,
                TimeBetweenGroups: 0.5,
                GroupSize: randint(1, 3),
                Zombies: []
            };

            // Populate zombies based on the pool
            for (let i = 0; i < num; i++) {
                objdata.Zombies.push({ "Type": `RTID(${choice(pool)}@ZombieTypes)` });
            }

            // Return pool for dark type storms
            if (type == 'dark') {
                return pool;
            }

            // Append the storm ambush to the wave
            append0(objdata, "StormZombieSpawnerProps", `wave${wave}ambush`);
        }

        /*
        "GroupSize": 3,
        "SwashbucklerCount": 3,
        "TimeBetweenGroups": 1
        */

        function raidingParty(wave) {
            let violence= getViolence(wave);
            let objdata = new Object();
            let times = [1.5, 1.25, 1.0, 0.75, 0.5, 0.25, 0.1];

            objdata.GroupSize = randint(1, 3);
            switch (violence) {
                case 0:
                    objdata.TimeBetweenGroups = times[0];
                    objdata.SwashbucklerCount = 1;
                    break;
                case 1:
                    objdata.TimeBetweenGroups = times[randint(1, 4)];
                    objdata.SwashbucklerCount = randint(2, 3);
                    break;
                case 2:
                    objdata.TimeBetweenGroups = times[randint(3, 5)];
                    objdata.SwashbucklerCount = randint(2, 5);
                    break;
                case 3:
                    objdata.TimeBetweenGroups = times[randint(5, 6)];
                    objdata.SwashbucklerCount = randint(1, 3);
                    break;
                case 4:
                    objdata.TimeBetweenGroups = times[6];
                    objdata.SwashbucklerCount = randint(2, difficulty/2 + 13);
                    break;
                default:
                    objdata.TimeBetweenGroups = times[6];
                    objdata.SwashbucklerCount = randint(2, difficulty/2 + 14);
                    break;
            }
            append0(objdata, 'RaidingPartyZombieSpawnerProps', `wave${wave}ambush`);
        }

        function rain(wave) {
            var num = 0;
            var start = 0;
            var end = 0;
            var time = 0;
            let violence= getViolence(wave);
            switch (violence) {
                case 0:
                    time = 1.5;
                    start = 6;
                    end = 8;
                    num = randint(1, 2);
                    break;
                case 1:
                    time = 1.25;
                    start = 5;
                    end = 7;
                    num = randint(2, 4);
                    break;
                case 2:
                    time = 1.05;
                    start = 3;
                    end = 6;
                    num = randint(4, 5);
                    break;
                case 3:
                    time = 1;
                    start = 3;
                    end = 6;
                    num = randint(3, 7);
                    break;
                case 4:
                    time = 0.5;
                    start = 2;
                    end = 6;
                    num = randint(5, difficulty);
                    break;
                default:
                    time = 0.25;
                    start = 2;
                    end = 6;
                    num = randint(3, difficulty);
            }
            let objclass, name, message;
            switch (stage) {
                case 'Future':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'future_imp'
                    message = choice(['Bot Swarm!', 'Fallen Technologie!'])
                    break;
                case 'Harvest':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = choice(['harvest_imp','spring_imp'])
                    message = 'Feather Falling!'
                    break;
                case 'LostCity':
                    objclass = 'ParachuteRainZombieSpawnerProps'
                    name = choice(['lostcity_lostpilot','lostcity_lostpilot',"zcorp_helpdesk"])
                    if (name == "zcorp_helpdesk"){
                        message = 'inzanity support!'
                    }
                    else {
                        message = 'Parachute Rain!'
                    }
                    break;
                case 'Summer':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'summer_imp'
                    message = 'Hot Dogs!'
                    break;
                case 'Xmas':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'feastivus_imp'
                    message = 'imp spirit !'
                    break;
                case 'Paddys':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'leprachaun_imp'
                    message = 'Leprachaun!'
                    break;
                case 'Hero':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'hero_impfinity'
                    message = 'Impfinity Clones!'
                    break;
                case 'Spring':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'spring_imp'
                    message = 'Egg rain!'
                    break;
                case 'Valentine':
                    objclass = 'SpiderRainZombieSpawnerProps'
                    name = 'valentines_imp'
                    message = 'Cupid Rain!'
                    break;

                default:
                    if (Math.random() < 0.2) {
                        objclass = 'ParachuteRainZombieSpawnerProps'
                        name = 'zcorp_helpdesk'
                        message = 'inzanity support!'
                    }
                    break;
            }
            let objdata = new Object();
            objdata.ColumnStart = start;
            objdata.ColumnEnd = end;
            objdata.SpiderCount = num;
            objdata.TimeBetweenGroups = `${time}`;
            objdata.ZombieFallTime = `${time}`;
            objdata.SpiderZombieName = name;
            objdata.WaveStartMessage = message;
            append0(objdata, objclass, `wave${wave}ambush`);
        }

        function necromancy(wave, violence) {
            let objdata = new Object();
            objdata.AdditionalPlantfood = '0';
            objdata.GridTypes = ["RTID(gravestone_dark@GridItemTypes)"];
            objdata.WaveStartMessage = '[WARNING_GRAVESTONE_SPAWN]';
            objdata.ZombieSpawnWaitTime = '1';
            objdata.Zombies = stormAmbush(wave, 'dark', violence);
            append0(objdata, "SpawnZombiesFromGridItemSpawnerProps", `wave${wave}ambushExtra`);
        }

        // Function to generate grid spawn data
        function graveSpawn(wave, violence) {
            let num = randint(2,5);
            switch (violence) {
                case 0: num = randint(1, 2); break;
                case 1: num = randint(2, 4); break;
                case 2: num = randint(2, 6); break;
                case 3: num = randint(4, 8); break;
                case 4: num = randint(7, 12); break;
                default: num = randint(7, 12); break;
            };
            let sun = 0;
            let regular = 0;
            while (num !== 0) {
                let diceRoll = randint(1, num);
                regular += diceRoll;
                num -= diceRoll;
                diceRoll = randint(1, num);
                sun += diceRoll;
                num -= diceRoll;
            }
            let objdata = new Object();
            objdata.GravestonePool = [
                { "Count": Math.abs(regular), "Type": "RTID(gravestone_dark@GridItemTypes)" },
                { "Count": Math.abs(sun), "Type": "RTID(gravestoneSunOnDestruction@GridItemTypes)" }
            ]
            objdata.SpawnEffectAnimID = 'POPANIM_EFFECTS_TOMBSTONE_DARK_SPAWN_EFFECT';
            objdata.SpawnPositionsPool = [{ "mX": 1, "mY": 0 }, { "mX": 1, "mY": 1 }, { "mX": 1, "mY": 2 }, { "mX": 1, "mY": 3 }, { "mX": 1, "mY": 4 }, { "mX": 2, "mY": 0 }, { "mX": 2, "mY": 1 }, { "mX": 2, "mY": 2 }, { "mX": 2, "mY": 3 }, { "mX": 2, "mY": 4 }, { "mX": 3, "mY": 0 }, { "mX": 3, "mY": 1 }, { "mX": 3, "mY": 2 }, { "mX": 3, "mY": 3 }, { "mX": 3, "mY": 4 }, { "mX": 4, "mY": 0 }, { "mX": 4, "mY": 1 }, { "mX": 4, "mY": 2 }, { "mX": 4, "mY": 3 }, { "mX": 4, "mY": 4 }, { "mX": 5, "mY": 0 }, { "mX": 5, "mY": 1 }, { "mX": 5, "mY": 2 }, { "mX": 5, "mY": 3 }, { "mX": 5, "mY": 4 }, { "mX": 6, "mY": 0 }, { "mX": 6, "mY": 1 }, { "mX": 6, "mY": 2 }, { "mX": 6, "mY": 3 }, { "mX": 6, "mY": 4 }, { "mX": 7, "mY": 0 }, { "mX": 7, "mY": 1 }, { "mX": 7, "mY": 2 }, { "mX": 7, "mY": 3 }, { "mX": 7, "mY": 4 }, { "mX": 8, "mY": 0 }, { "mX": 8, "mY": 1 }, { "mX": 8, "mY": 2 }, { "mX": 8, "mY": 3 }, { "mX": 8, "mY": 4 }];
            objdata.SpawnSoundID = 'Play_Zomb_Egypt_TombRaiser_Grave_Rise';
            append0(objdata, "SpawnGravestonesWaveActionProps", `wave${wave}ambush`);
        }

    


    




        function ambush(wave) {
            if (stage === 'West') {
                return;
            }

            switch (stage) {
                case 'Modern':
                    portalSpawn(wave);
                    break;
                case 'Iceage':
                    ambushRoulette(wave);
                    break;
                case 'Xmas':
                    ambushRoulette(wave);
                    break;
                case 'Egypt':
                    stormAmbush(wave, 'sand');
                    break;
                case 'Pirate':
                    raidingParty(wave);
                    break;
                    case `Summer`:
                    case `Xmas`:
                    case `Harvest`:
                    case 'Future':
                    case 'Paddys':
                    case 'Spring':
                    case 'Valentine':
                    case 'Hero':
                case 'LostCity':
                    rain(wave);
                    break;
                case 'Dark':
                    ambushRoulette(wave);
                    break;
                case 'Beach':
                    let columns = [9, 8, 7, 6, 5, 4, 3, 2, 1];
                    let index = randint(0, columns.length - 1);

                    // Get the violence level based on the wave index
                    let violence = getViolence(wave); 

                    // Random zombie selection based on violence level
                    let zombies = ['beach_armor1', 'beach_fem']; // Replace with actual zombie types
                    let zombieCount = 1; // Randomize number of zombies based on violence
                    let selectedZombies = choice(zombies); // Select a random zombie type

                    // Apply tidal changes for specific waves
                    append0({
                        "TidalChange": {
                            "ChangeAmount": columns[index],  // Change tide based on random column
                            "ChangeType": "absolute"         // Absolute change type
                        },
                    }, 'TidalChangeWaveActionProps', `wave${wave}ambush`);

                    // Spawn zombies with low tide event
                    append0({
                        "objclass": "BeachStageEventZombieSpawnerProps",
                        "objdata": {
                            "ColumnStart": 5,
                            "ColumnEnd": 7,
                            "ZombieCount": zombieCount,      // Number of zombies based on violence level
                            "GroupSize": 1,
                            "TimeBetweenGroups": "0.05",
                            "ZombieName": `${selectedZombies}`, // Selected zombie type
                            "WaveStartMessage": "Low Tide!"
                        }
                    }, 'BeachStageEventZombieSpawnerProps', `wave${wave}ambushExtra`);

                    break;


                default:
                    break;
            }
        }


        function winds(wave, violence) {
            let winds = [{ "Direction": "left", "Row": "0" }, { "Direction": "left", "Row": "1" }, { "Direction": "left", "Row": "2" }, { "Direction": "left", "Row": "3" }, { "Direction": "left", "Row": "4" }, { "Direction": "right", "Row": "0" }, { "Direction": "right", "Row": "1" }, { "Direction": "right", "Row": "2" }, { "Direction": "right", "Row": "3" }, { "Direction": "right", "Row": "4" }];
            let objdata = new Object();
            let temp = [];
            switch (violence) {
                case 0: temp = sample(winds, randint(1, 2)); break;
                case 1: temp = sample(winds, randint(1, 4)); break;
                case 2: temp = sample(winds, randint(2, 6)); break;
                case 3: temp = sample(winds, randint(3, 8)); break;
                case 4: temp = sample(winds, randint(4, 10)); break;
            }
            objdata.Winds = temp;
            append0(objdata, 'FrostWindWaveActionProps', `wave${wave}ambushExtra`)
        }

        function ambushRoulette(wave) {
            let diceRoll;
            let violence= getViolence(wave);
            if (violence > 1) { diceRoll = randint(1, 3); }
            else diceRoll = randint(1, 2);
            switch (diceRoll) {
                case 1:
                    let violence1 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        necromancy(wave, violence1);
                    } else {
                        stormAmbush(wave, 'snow', violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambushExtra`);
                    break;

                case 2:
                    let violence2 = Math.max(0, violence - 3 + difficulty);
                    if (stage == 'Dark') {
                        necromancy(wave, violence2);
                    } else {
                        winds(wave, violence);
                    }
                    append0({ "Zombies": [] }, "SpawnZombiesJitteredWaveActionProps", `wave${wave}ambush`);
                    break;

                case 3:
                    let violence3 = Math.max(0, violence - 5 + difficulty);
                    if (stage == 'Dark') {
                        graveSpawn(wave, violence3);
                        necromancy(wave, Math.max(0, violence - 5 + difficulty));
                    } else {
                        stormAmbush(wave, 'snow', Math.max(0, violence - 5 + difficulty));
                        winds(wave, violence);
                    }
                    break;

                default:
                    break;
            }

        }

    </script>
</body>

</html>